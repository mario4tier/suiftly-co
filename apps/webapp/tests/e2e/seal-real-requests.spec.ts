/**
 * Real Seal Requests E2E Tests
 *
 * Tests the full production flow (real user experience):
 * 1. Customer subscribes to Seal service through UI
 * 2. Customer creates seal key + package through UI (triggers cpEnabled)
 * 3. API key is auto-created during subscription
 * 4. Vault is generated by GM with customer config
 * 5. LM applies vault to HAProxy
 * 6. Real HTTP requests through HAProxy using API key
 *
 * Prerequisites:
 * - HAProxy running with Seal frontend configured
 * - Local Manager (LM) running and consuming vaults
 * - Global Manager (GM) running for vault generation
 * - API server running with test endpoints
 *
 * Port reference (~/walrus/PORT_MAP.md):
 * - 20202: SEAL local access (unmetered) - used for testing
 * - 22600: Global Manager API
 * - 22610: Local Manager API
 * - 22700: API Server
 */

import { test, expect } from '@playwright/test';
import { waitAfterMutation } from '../helpers/wait-utils';
import { resetCustomer, ensureTestBalance } from '../helpers/db';
// Note: We intentionally don't use setupCpEnabled or createApiKey shortcuts
// to test the real user experience through the UI
import {
  sealHealthCheck,
  isHAProxyAvailable,
  isSealBackendAvailable,
  SEAL_PORTS,
} from '../helpers/seal-requests';

// Service URLs
const LM_URL = 'http://localhost:22610';
const GM_URL = 'http://localhost:22600';
const API_URL = 'http://localhost:22700';

// Test configuration
// Use MAINNET_PUBLIC (20002) for API key validation tests - this is the metered frontend
// that validates X-API-Key headers. MAINNET_LOCAL (20202) is unmetered and skips validation.
const SEAL_METERED_PORT = SEAL_PORTS.MAINNET_PUBLIC; // 20002 - metered, validates API keys
const SEAL_LOCAL_PORT = SEAL_PORTS.MAINNET_LOCAL; // 20202 - unmetered, no API key validation

// LM health response structure
interface LMHealthResponse {
  service: string;
  timestamp: string;
  vaults: Array<{
    type: string;
    customerCount: number;
    applied: { seq: number; at: string } | null;
    processing: object | null;
  }>;
}

// Helper to get LM health status
async function getLMHealth(): Promise<LMHealthResponse | null> {
  try {
    const response = await fetch(`${LM_URL}/api/health`);
    if (!response.ok) return null;
    return response.json();
  } catch {
    return null;
  }
}

// Helper to wait for vault to propagate and be applied by LM
// Options:
// - requireCustomers: if true, also waits for customerCount > 0
async function waitForVaultSync(expectedMinSeq: number, options?: { requireCustomers?: boolean }): Promise<number> {
  const maxAttempts = 120; // 60 seconds total (increased for race condition handling)
  const pollInterval = 500;
  const requireCustomers = options?.requireCustomers ?? false;

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const health = await getLMHealth();
    if (health) {
      const smaVault = health.vaults.find((v) => v.type === 'sma');
      if (
        smaVault?.applied &&
        smaVault.applied.seq >= expectedMinSeq &&
        !smaVault.processing &&
        (!requireCustomers || smaVault.customerCount > 0)
      ) {
        console.log(
          `Vault sync detected after ${(attempt + 1) * pollInterval}ms (seq=${smaVault.applied.seq}, customers=${smaVault.customerCount})`
        );
        return smaVault.customerCount;
      }
    }
    await new Promise((resolve) => setTimeout(resolve, pollInterval));
  }

  throw new Error(
    `Vault sync timed out after ${maxAttempts * pollInterval}ms waiting for seq >= ${expectedMinSeq}${requireCustomers ? ' with customers' : ''}`
  );
}

// Helper to trigger GM vault generation
async function triggerGMSync(): Promise<void> {
  await fetch(`${GM_URL}/api/queue/sync-all?source=e2e-real-seal-test`, {
    method: 'POST',
  });
}

// API key type from listApiKeys endpoint
interface ApiKeyInfo {
  apiKeyFp: number;
  keyPreview: string;
  fullKey: string;
  metadata: unknown;
  isUserEnabled: boolean;
  createdAt: string;
  revokedAt: string | null;
}

// Helper to get API keys via test endpoint
// This endpoint doesn't require authentication and returns decrypted keys
async function getApiKeys(request: import('@playwright/test').APIRequestContext): Promise<ApiKeyInfo[]> {
  const response = await request.get(`${API_URL}/test/data/api-keys`);
  if (!response.ok()) {
    throw new Error(`Failed to get API keys: ${await response.text()}`);
  }
  const data = await response.json();
  // Test endpoint returns { apiKeys: [...] } with apiKeyId (decrypted key)
  return (data.apiKeys || []).map((k: any) => ({
    apiKeyFp: k.apiKeyFp,
    keyPreview: `${k.apiKeyId.slice(0, 8)}...${k.apiKeyId.slice(-4)}`,
    fullKey: k.apiKeyId, // apiKeyId is the decrypted full key
    metadata: k.metadata,
    isUserEnabled: k.isUserEnabled,
    createdAt: k.createdAt,
    revokedAt: k.revokedAt,
  }));
}

test.describe('Real Seal Requests', () => {
  test.beforeAll(async () => {
    // Check prerequisites - HAProxy and LM must be running
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();

    if (!haproxyAvailable) {
      console.warn(
        `HAProxy not available on port ${SEAL_METERED_PORT}. Some tests will be skipped.`
      );
    }

    if (!lmHealth) {
      console.warn(
        'Local Manager not available. Vault sync tests will be skipped.'
      );
    }
  });

  test.beforeEach(async ({ page }) => {
    // Reset customer to clean state
    await resetCustomer(page.request);

    // Clear cookies for clean auth state
    await page.context().clearCookies();

    // Authenticate with mock wallet
    await page.goto('/');
    await page.click('button:has-text("Mock Wallet")');
    await waitAfterMutation(page);
    await page.waitForURL('/dashboard', { timeout: 10000 });

    // Ensure customer has balance for subscription
    await ensureTestBalance(page.request, 1000, { spendingLimitUsd: 250 });
  });

  test('full user flow: subscribe, configure, and verify vault sync', async ({ page }) => {
    test.setTimeout(90000); // Extended timeout for full flow

    // Check if LM is available
    const lmHealth = await getLMHealth();
    if (!lmHealth) {
      test.skip();
      return;
    }

    // Get initial vault sequence for later comparison
    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;
    console.log(`Initial vault seq: ${initialSeq}`);

    // === STEP 1: Subscribe to Seal service through UI ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });

    // Accept terms and select STARTER tier
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();

    // Subscribe to service
    const subscribeButton = page.locator('button:has-text("Subscribe to Service")');
    await subscribeButton.click();

    // Wait for subscription success
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    console.log('✅ Subscription successful - API key auto-created');

    // Wait for redirect to overview
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // === STEP 2: Enable the service via UI toggle ===
    const serviceToggle = page.locator('button[role="switch"]');
    const toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
      console.log('✅ Service enabled');
    }

    // === STEP 3: Create a Seal Key via UI (required for cpEnabled) ===
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);

    const addKeyButton = page.locator('button:has-text("Add New Seal Key")');
    await addKeyButton.click();
    await waitAfterMutation(page);
    await expect(
      page.locator('text=/Seal key created successfully/i')
    ).toBeVisible({ timeout: 5000 });
    console.log('✅ Seal key created');

    // === STEP 4: Add a package to trigger cpEnabled=true ===
    const addPackageButton = page
      .locator('button:has-text("Add Package to this Seal Key")')
      .first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);

    await expect(
      page.getByRole('heading', { name: 'Add Package' })
    ).toBeVisible({ timeout: 5000 });
    await page.locator('input#packageAddress').fill('0x' + '1'.repeat(64));
    await page.locator('input#name').fill('Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    console.log('✅ Package added - cpEnabled=true');

    // === STEP 5: Verify API key exists and get it via test endpoint ===
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);

    const apiKey = apiKeys[0].fullKey;
    const apiKeyFp = apiKeys[0].apiKeyFp;
    expect(apiKey).toBeDefined();
    expect(apiKey.length).toBe(37); // Expected format: S + 36 chars
    console.log(`✅ API key retrieved: ${apiKey.substring(0, 10)}...`);

    // === STEP 5b: Verify UI clipboard copy matches API key ===
    // This ensures what users copy from the UI matches what we use for testing
    await page.goto('/services/seal/overview?tab=x-api-key');
    await waitAfterMutation(page);

    // Find the API key row by its fingerprint and click the copy button
    const apiKeyRow = page.locator(`[data-testid="apik-${apiKeyFp}"]`);
    await expect(apiKeyRow).toBeVisible({ timeout: 5000 });

    // Click the copy button (the Copy icon button inside CopyableValue)
    const copyButton = apiKeyRow.locator('button').first();
    await copyButton.click();

    // Read clipboard content (requires clipboard-read permission granted in playwright config)
    const clipboardContent = await page.evaluate(() => navigator.clipboard.readText());

    // Verify clipboard matches the API key from tRPC
    expect(clipboardContent).toBe(apiKey);
    console.log(`✅ UI clipboard copy verified: matches API key from tRPC`);

    // === STEP 6: Trigger GM vault generation ===
    await triggerGMSync();
    console.log('✅ GM vault sync triggered');

    // === STEP 7: Wait for vault to be applied by LM with our customer ===
    // Use requireCustomers to handle race condition where vault might be applied
    // before our cpEnabled change is included
    const customerCount = await waitForVaultSync(initialSeq + 1, { requireCustomers: true });
    console.log(`✅ Vault sync complete - ${customerCount} customer(s) in HAProxy`);
  });

  test('HAProxy health check with valid API key', async ({ page }) => {
    test.setTimeout(120000); // Extended timeout for full flow

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();

    if (!haproxyAvailable) {
      console.log('Skipping: HAProxy not available');
      test.skip();
      return;
    }

    if (!lmHealth) {
      console.log('Skipping: LM not available');
      test.skip();
      return;
    }

    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;

    // === Subscribe and configure through UI (real user experience) ===

    // Navigate to Seal service
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });

    // Accept terms and subscribe
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service
    const serviceToggle = page.locator('button[role="switch"]');
    const toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    // Add package (triggers cpEnabled)
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '2'.repeat(64));
    await page.locator('input#name').fill('HAProxy Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);

    // Get API key via test endpoint
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);
    const apiKey = apiKeys[0].fullKey;
    console.log(`API key from UI flow: ${apiKey.substring(0, 10)}... (${apiKey.length} chars)`);

    // Trigger vault sync and wait for our customer to be included
    await triggerGMSync();
    await waitForVaultSync(initialSeq + 1, { requireCustomers: true });

    // === Now make a real health check request through HAProxy (metered port) ===
    const healthResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });

    console.log('Health check response:', healthResponse);

    // Verify the response
    if (healthResponse.status === 401) {
      console.warn(
        'HAProxy returned 401 - API key validation failed'
      );
      console.log('Response body:', healthResponse.body);
    }

    // For now, we expect either success or a specific error we can debug
    // 200 = success, 401/403 = auth issue, 502/503 = backend issue
    expect([200, 401, 403, 502, 503]).toContain(healthResponse.status);

    if (healthResponse.status === 200) {
      console.log('✅ HAProxy health check succeeded with valid API key!');
    }
  });

  test('local port (20202) bypasses API key validation - returns 200', async () => {
    // Check if HAProxy is available on local port
    const haproxyAvailable = await isHAProxyAvailable();
    if (!haproxyAvailable) {
      console.log('Skipping: HAProxy not available on local port');
      test.skip();
      return;
    }

    // Check if the real Seal backend (mseal1) is running
    const backendAvailable = await isSealBackendAvailable();
    expect(backendAvailable,
      'Seal backend (mseal1) not running on port 20401. Start it with: sudo systemctl start mseal1-node'
    ).toBe(true);
    console.log('✅ Seal backend (mseal1) is healthy');

    // Make request without API key on local port
    // Local port (20202) is unmetered and bypasses API key validation
    const response = await sealHealthCheck({
      apiKey: '', // No API key
      port: SEAL_LOCAL_PORT,
    });

    console.log('Response on local port without API key:', response);

    // Local port MUST return 200 to prove:
    // 1. API key validation was bypassed (not 401)
    // 2. Request reached the backend successfully (not 502/503)
    expect(response.status).toBe(200);
    console.log('✅ Local port bypasses API key validation - got 200 from backend');
  });

  test('service toggle triggers vault sync - metered port validates GLIM', async ({ page }) => {
    test.setTimeout(180000); // Extended timeout for full flow with vault sync

    // Prerequisites:
    // - HAProxy with X_API_KEY_SECRET configured (shared with API server)
    // - LM running and applying vaults to HAProxy
    // - GM running for vault generation
    // - mseal1 backend running
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth) {
      console.log('Skipping: HAProxy or LM not available');
      test.skip();
      return;
    }

    expect(backendAvailable,
      'Seal backend (mseal1) not running on port 20401. Start it with: sudo systemctl start mseal1-node'
    ).toBe(true);

    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;

    // === STEP 1: Subscribe and configure through UI ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service initially
    const serviceToggle = page.locator('button[role="switch"]');
    let toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    // Add package (triggers cpEnabled)
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '3'.repeat(64));
    await page.locator('input#name').fill('Toggle Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    console.log('✅ Service configured with seal key and package');

    // Get API key for metered port requests
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);
    const apiKey = apiKeys[0].fullKey;
    console.log(`✅ API key retrieved: ${apiKey.substring(0, 10)}... (${apiKey.length} chars)`);

    // Trigger vault sync and wait for customer to be included
    await triggerGMSync();
    await waitForVaultSync(initialSeq + 1, { requireCustomers: true });
    console.log('✅ Initial vault sync complete');

    // === STEP 2: Verify service ON returns 200 via metered port with API key ===
    // This validates the full flow: API key decryption → customer lookup → GLIM check → backend
    let response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });
    console.log('Service ON response on metered port:', response);
    expect(response.status).toBe(200);
    console.log('✅ Service ON: metered port returns 200 (API key valid, GLIM>0)');

    // === STEP 3: Turn OFF service via UI toggle ===
    await page.goto('/services/seal/overview');
    await waitAfterMutation(page);
    const toggleOff = page.locator('button[role="switch"]');
    toggleState = await toggleOff.getAttribute('aria-checked');
    if (toggleState === 'true') {
      await toggleOff.click();
      await waitAfterMutation(page);
    }
    console.log('✅ Service toggled OFF via UI');

    // Trigger vault sync and wait
    const seqAfterOff = (await getLMHealth())?.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;
    await triggerGMSync();
    await waitForVaultSync(seqAfterOff + 1, { requireCustomers: true });
    console.log('✅ Vault sync after OFF complete');

    // === STEP 4: Verify service OFF returns 403 via metered port ===
    // When isUserEnabled=false, GLIM=0 in config map → HAProxy returns 403
    response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });
    console.log('Service OFF response on metered port:', response);

    // API key is valid (not 401), but customer not authorized (GLIM=0 → 403)
    expect(response.status).toBe(403);
    console.log('✅ Service OFF: metered port returns 403 (API key valid, but GLIM=0)');

    // === STEP 5: Turn ON service via UI toggle ===
    const toggleOn = page.locator('button[role="switch"]');
    toggleState = await toggleOn.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await toggleOn.click();
      await waitAfterMutation(page);
    }
    console.log('✅ Service toggled ON via UI');

    // Trigger vault sync and wait
    const seqAfterOn = (await getLMHealth())?.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;
    await triggerGMSync();
    await waitForVaultSync(seqAfterOn + 1, { requireCustomers: true });
    console.log('✅ Vault sync after ON complete');

    // === STEP 6: Verify service ON returns 200 again via metered port ===
    response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });
    console.log('Service ON (restored) response on metered port:', response);
    expect(response.status).toBe(200);
    console.log('✅ Service ON: metered port returns 200 again (GLIM restored)');
  });

  test('metered port (20002) rejects request without API key', async () => {
    // Check if HAProxy is available on metered port
    const haproxyAvailable = await isHAProxyAvailable();
    if (!haproxyAvailable) {
      test.skip();
      return;
    }

    // Make request without API key on metered port
    const response = await sealHealthCheck({
      apiKey: '', // Empty API key
      port: SEAL_METERED_PORT,
    });

    console.log('Response on metered port without API key:', response);

    // Metered port should reject with 401 (missing API key)
    expect(response.status).toBe(401);
    console.log('✅ Metered port correctly rejects missing API key');
  });

  test('metered port (20002) rejects request with invalid API key', async () => {
    // Check if HAProxy is available on metered port
    const haproxyAvailable = await isHAProxyAvailable();
    if (!haproxyAvailable) {
      test.skip();
      return;
    }

    // Make request with invalid API key (wrong format/checksum)
    const response = await sealHealthCheck({
      apiKey: 'SINVALIDAPIKEY12345678901234567890',
      port: SEAL_METERED_PORT,
    });

    console.log('Response on metered port with invalid API key:', response);

    // Metered port should reject with 401 (invalid API key)
    expect(response.status).toBe(401);
    console.log('✅ Metered port correctly rejects invalid API key');
  });
});

test.describe('Real Seal Requests - Infrastructure Checks', () => {
  test('HAProxy stats endpoint is accessible', async () => {
    try {
      const response = await fetch('http://localhost:1936/haproxy?stats');
      console.log(`HAProxy stats: ${response.status}`);
      // Stats endpoint should be available even if Seal frontend isn't configured
      expect(response.status).toBe(200);
    } catch (error) {
      console.log('HAProxy stats not available:', error);
      test.skip();
    }
  });

  test('Local Manager health endpoint is accessible', async () => {
    const health = await getLMHealth();
    if (!health) {
      console.log('LM not available');
      test.skip();
      return;
    }

    expect(health.service).toBe('local-manager');
    expect(health.vaults).toBeDefined();
    console.log('LM health:', JSON.stringify(health, null, 2));
  });

  test('Global Manager is accessible', async () => {
    try {
      const response = await fetch(`${GM_URL}/api/health`);
      if (!response.ok) {
        console.log('GM not available');
        test.skip();
        return;
      }

      const health = await response.json();
      console.log('GM health:', JSON.stringify(health, null, 2));
      expect(health).toBeDefined();
    } catch {
      console.log('GM not available');
      test.skip();
    }
  });
});
