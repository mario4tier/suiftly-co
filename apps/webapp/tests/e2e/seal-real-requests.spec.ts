/**
 * Real Seal Requests E2E Tests
 *
 * Tests the full production flow (real user experience):
 * 1. Customer subscribes to Seal service through UI
 * 2. Customer creates seal key + package through UI (triggers cpEnabled)
 * 3. API key is auto-created during subscription
 * 4. Vault is generated by GM with customer config
 * 5. LM applies vault to HAProxy
 * 6. Real HTTP requests through HAProxy using API key
 *
 * Prerequisites:
 * - HAProxy running with Seal frontend configured
 * - Local Manager (LM) running and consuming vaults
 * - Global Manager (GM) running for vault generation
 * - API server running with test endpoints
 *
 * Port reference (~/mhaxbe/PORT_MAP.md):
 * - 20202: SEAL local access (unmetered) - used for testing
 * - 22600: Global Manager API
 * - 22610: Local Manager API
 * - 22700: API Server
 */

import { test, expect } from '@playwright/test';
import { waitAfterMutation } from '../helpers/wait-utils';
import { ServiceStabilityChecker } from '../helpers/service-stability';
import { resetCustomer, ensureTestBalance, getCustomerData, waitForHaproxyLogs } from '../helpers/db';
// Note: We intentionally don't use setupCpEnabled or createApiKey shortcuts
// to test the real user experience through the UI
import {
  sealHealthCheck,
  isHAProxyAvailable,
  isSealBackendAvailable,
  SEAL_PORTS,
} from '../helpers/seal-requests';

// Service URLs
const LM_URL = 'http://localhost:22610';
const GM_URL = 'http://localhost:22600';
const API_URL = 'http://localhost:22700';

// Test configuration
// Use MAINNET_PUBLIC (20002) for API key validation tests - this is the metered frontend
// that validates X-API-Key headers. MAINNET_LOCAL (20202) is unmetered and skips validation.
const SEAL_METERED_PORT = SEAL_PORTS.MAINNET_PUBLIC; // 20002 - metered, validates API keys
const SEAL_LOCAL_PORT = SEAL_PORTS.MAINNET_LOCAL; // 20202 - unmetered, no API key validation

// LM health response structure
interface LMHealthResponse {
  service: string;
  timestamp: string;
  vaults: Array<{
    type: string;
    customerCount: number;
    applied: { seq: number; at: string } | null;
    processing: object | null;
  }>;
}

// Helper to get LM health status
async function getLMHealth(): Promise<LMHealthResponse | null> {
  try {
    const response = await fetch(`${LM_URL}/api/health`);
    if (!response.ok) return null;
    return response.json();
  } catch {
    return null;
  }
}
// Sudob API URL (privileged service for root operations)
const SUDOB_URL = 'http://127.0.0.1:22800';

// HAProxy config verification result
interface HAProxyConfigCheck {
  ok: boolean;
  version: number;
  customerId: number | null;
  headerHex: string | null;  // Full 16-char header for debugging
  glim: number | null;       // GLIM value (positions 7-8)
  controlFlags: number | null;
  hasIpAllowlist: boolean | null;
  inlineIps: string[] | null;
  error?: string;
}

// Helper to verify HAProxy config.map contains expected customer config
// Uses sudob to query HAProxy socket directly
async function verifyHAProxyConfig(
  customerId: number,
  expectedConfig?: {
    hasIpAllowlist?: boolean;
    inlineIps?: string[];
    glim?: number;  // Expected GLIM value (0 = service disabled)
  }
): Promise<HAProxyConfigCheck> {
  const result: HAProxyConfigCheck = {
    ok: false,
    version: 0,
    customerId: null,
    headerHex: null,
    glim: null,
    controlFlags: null,
    hasIpAllowlist: null,
    inlineIps: null,
  };

  try {
    // Query HAProxy config.map via sudob
    const response = await fetch(`${SUDOB_URL}/api/haproxy/socket`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ command: 'show map /etc/haproxy/conf.d/204-mseal_config.map' }),
    });

    if (!response.ok) {
      result.error = `Sudob request failed: ${response.status}`;
      return result;
    }

    const data = await response.json();
    if (!data.ok) {
      result.error = `HAProxy socket error: ${data.error}`;
      return result;
    }

    // Parse the map output
    const lines = data.output.split('\n');
    for (const line of lines) {
      // Parse __version__ metadata
      const versionMatch = line.match(/__version__\s+(\d+)/);
      if (versionMatch) {
        result.version = parseInt(versionMatch[1], 10);
        continue;
      }

      // Parse customer entry: <hex_id> <customer_id> <config_csv>
      // Format: 0x75e178e99080 1886853509 0000010060620002,ad8cf08d00000000,0a141e28323c4650,0000000000000000
      const customerMatch = line.match(/0x[0-9a-f]+\s+(\d+)\s+([0-9a-f]{16}),([0-9a-f]{16}),([0-9a-f]{16}),([0-9a-f]{16})/i);
      if (customerMatch && parseInt(customerMatch[1], 10) === customerId) {
        result.customerId = customerId;

        // Parse header (16 hex chars): 00000ILGLBLQCCCC
        // Positions: 5-6=IL(ILIM), 7-8=GL(GLIM), 9-10=BL(BLIM), 11=Q(BQoS), 12-15=CCCC(ControlFlags)
        const headerHex = customerMatch[2];
        result.headerHex = headerHex;
        result.glim = parseInt(headerHex.slice(7, 9), 16);  // GLIM at positions 7-8
        result.controlFlags = parseInt(headerHex.slice(-4), 16);
        result.hasIpAllowlist = (result.controlFlags & 0x0002) !== 0;

        // Parse IP filter (16 hex chars): IP1(8hex)IP2(8hex)
        const ipFilterHex = customerMatch[4];
        const ip1Hex = ipFilterHex.slice(0, 8);
        const ip2Hex = ipFilterHex.slice(8, 16);

        // Convert hex to IP address
        const hexToIp = (hex: string): string | null => {
          const num = parseInt(hex, 16);
          if (num === 0) return null;
          return [
            (num >>> 24) & 0xff,
            (num >>> 16) & 0xff,
            (num >>> 8) & 0xff,
            num & 0xff,
          ].join('.');
        };

        const ip1 = hexToIp(ip1Hex);
        const ip2 = hexToIp(ip2Hex);
        result.inlineIps = [ip1, ip2].filter(Boolean) as string[];
        // Don't break - continue parsing to also get __version__
      }
    }

    // Verify expected config if provided
    if (expectedConfig) {
      if (result.customerId === null) {
        result.error = `Customer ${customerId} not found in HAProxy config.map`;
        return result;
      }

      if (expectedConfig.hasIpAllowlist !== undefined) {
        if (result.hasIpAllowlist !== expectedConfig.hasIpAllowlist) {
          result.error = `IP allowlist bit mismatch: expected ${expectedConfig.hasIpAllowlist}, got ${result.hasIpAllowlist}`;
          return result;
        }
      }

      if (expectedConfig.inlineIps) {
        const expectedIpsSet = new Set(expectedConfig.inlineIps);
        const actualIpsSet = new Set(result.inlineIps || []);
        const missing = expectedConfig.inlineIps.filter(ip => !actualIpsSet.has(ip));
        if (missing.length > 0) {
          result.error = `Missing inline IPs: expected ${expectedConfig.inlineIps.join(',')}, got ${result.inlineIps?.join(',') || 'none'}`;
          return result;
        }
      }

      if (expectedConfig.glim !== undefined) {
        if (result.glim !== expectedConfig.glim) {
          result.error = `GLIM mismatch: expected ${expectedConfig.glim}, got ${result.glim}`;
          return result;
        }
      }
    }

    result.ok = true;
    return result;
  } catch (error) {
    result.error = `Exception: ${error instanceof Error ? error.message : String(error)}`;
    return result;
  }
}

// Helper to wait for HAProxy config to match expected state
// This is more reliable than waiting for vault seq because it verifies actual config
//
// IMPORTANT: When verifying a config CHANGE (not first-time setup), always pass
// minVersion from the previous configCheck.version. This ensures a new vault was
// actually generated and applied, not just checking the existing config state.
async function waitForHAProxyConfig(
  customerId: number,
  expectedConfig: {
    hasIpAllowlist?: boolean;
    inlineIps?: string[];
    glim?: number;  // Expected GLIM value (0 = service disabled)
  },
  options?: {
    timeout?: number;
    pollInterval?: number;
    // Minimum version required - use this when verifying a config CHANGE
    // to ensure a new vault was generated (version must be > minVersion)
    minVersion?: number;
  }
): Promise<HAProxyConfigCheck> {
  const timeout = options?.timeout ?? 30000;
  const pollInterval = options?.pollInterval ?? 500;
  const minVersion = options?.minVersion;
  const maxAttempts = Math.ceil(timeout / pollInterval);

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const result = await verifyHAProxyConfig(customerId, expectedConfig);

    // Check version increment if minVersion specified
    if (result.ok && minVersion !== undefined) {
      if (result.version <= minVersion) {
        // Config matches but version hasn't incremented yet - keep waiting
        result.ok = false;
        result.error = `Version not incremented: current=${result.version}, need>${minVersion}`;
      }
    }

    if (result.ok) {
      console.log(
        `HAProxy config verified after ${(attempt + 1) * pollInterval}ms: ` +
        `version=${result.version}, header=${result.headerHex}, GLIM=${result.glim}, ` +
        `controlFlags=0x${result.controlFlags?.toString(16)}, ` +
        `hasIpAllowlist=${result.hasIpAllowlist}, inlineIps=[${result.inlineIps?.join(',')}]`
      );
      return result;
    }

    if (attempt < maxAttempts - 1) {
      await new Promise((resolve) => setTimeout(resolve, pollInterval));
    }
  }

  // Return last result with error - MUST set ok=false on timeout
  const finalResult = await verifyHAProxyConfig(customerId, expectedConfig);
  finalResult.ok = false;
  if (minVersion !== undefined && finalResult.version <= minVersion) {
    finalResult.error = `Timeout: version not incremented (current=${finalResult.version}, need>${minVersion})`;
  } else {
    finalResult.error = `Timeout waiting for HAProxy config: ${finalResult.error || 'config not found'}`;
  }
  return finalResult;
}

// Helper to wait for both customer config AND API key to be synced to HAProxy
// This does a test health check to verify the full path works
async function waitForHAProxyReady(
  customerId: number,
  apiKey: string,
  options?: {
    timeout?: number;
    pollInterval?: number;
    retryDelay?: number;
  }
): Promise<HAProxyConfigCheck> {
  const timeout = options?.timeout ?? 60000;
  const pollInterval = options?.pollInterval ?? 500;
  const retryDelay = options?.retryDelay ?? 3000;
  const startTime = Date.now();

  // First, wait for customer to appear in config map
  const configCheck = await waitForHAProxyConfig(customerId, {}, { timeout: timeout / 2, pollInterval });
  if (!configCheck.ok) {
    return configCheck;
  }

  // Then, retry health check until API key is also synced
  const maxRetries = Math.ceil((timeout / 2) / retryDelay);
  for (let retry = 0; retry < maxRetries; retry++) {
    const response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });

    if (response.status === 200) {
      console.log(`✅ HAProxy ready: customer ${customerId} + API key synced (took ${Date.now() - startTime}ms)`);
      return configCheck;
    }

    if (response.status === 403) {
      // API key valid but customer not authorized (GLIM=0) - might need more time
      console.log(`  ⏳ Attempt ${retry + 1}/${maxRetries} got 403 (GLIM=0), retrying in ${retryDelay}ms...`);
    } else if (response.status === 401) {
      // API key not found yet
      console.log(`  ⏳ Attempt ${retry + 1}/${maxRetries} got 401 (API key not synced), retrying in ${retryDelay}ms...`);
    } else {
      // Unexpected status - might be backend issue
      console.log(`  ⏳ Attempt ${retry + 1}/${maxRetries} got ${response.status}, retrying in ${retryDelay}ms...`);
    }

    if (retry < maxRetries - 1) {
      await new Promise((resolve) => setTimeout(resolve, retryDelay));
    }
  }

  // Timeout - return config check but mark as failed
  configCheck.ok = false;
  configCheck.error = `Timeout: customer config synced but API key or GLIM not ready after ${timeout}ms`;
  return configCheck;
}

// Helper to wait for health check to return expected status
// Used after toggle changes to ensure HAProxy has fully applied the config
// Max wait time is 3 seconds (6 retries x 500ms)
async function waitForHealthCheckStatus(
  apiKey: string,
  expectedStatus: number
): Promise<{ status: number; ok: boolean }> {
  const maxRetries = 6;
  const retryDelay = 500;

  for (let retry = 0; retry < maxRetries; retry++) {
    const response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });

    if (response.status === expectedStatus) {
      console.log(`✅ Health check returned expected ${expectedStatus} after ${(retry + 1) * retryDelay}ms`);
      return { status: response.status, ok: true };
    }

    if (retry < maxRetries - 1) {
      console.log(`  ⏳ Got ${response.status}, waiting for ${expectedStatus}... (${(retry + 1) * retryDelay}ms)`);
      await new Promise((resolve) => setTimeout(resolve, retryDelay));
    }
  }

  // Return last status
  const finalResponse = await sealHealthCheck({ apiKey, port: SEAL_METERED_PORT });
  return { status: finalResponse.status, ok: false };
}

// API key type from listApiKeys endpoint
interface ApiKeyInfo {
  apiKeyFp: number;
  keyPreview: string;
  fullKey: string;
  metadata: unknown;
  isUserEnabled: boolean;
  createdAt: string;
  revokedAt: string | null;
}

// Helper to get API keys via test endpoint
// This endpoint doesn't require authentication and returns decrypted keys
async function getApiKeys(request: import('@playwright/test').APIRequestContext): Promise<ApiKeyInfo[]> {
  const response = await request.get(`${API_URL}/test/data/api-keys`);
  if (!response.ok()) {
    throw new Error(`Failed to get API keys: ${await response.text()}`);
  }
  const data = await response.json();
  // Test endpoint returns { apiKeys: [...] } with apiKeyId (decrypted key)
  return (data.apiKeys || []).map((k: any) => ({
    apiKeyFp: k.apiKeyFp,
    keyPreview: `${k.apiKeyId.slice(0, 8)}...${k.apiKeyId.slice(-4)}`,
    fullKey: k.apiKeyId, // apiKeyId is the decrypted full key
    metadata: k.metadata,
    isUserEnabled: k.isUserEnabled,
    createdAt: k.createdAt,
    revokedAt: k.revokedAt,
  }));
}

test.describe('Real Seal Requests', () => {
  // Service stability checker - detects unexpected service restarts during tests
  let stabilityChecker: ServiceStabilityChecker;

  test.beforeAll(async () => {
    // Check prerequisites - HAProxy and LM must be running
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();

    if (!haproxyAvailable) {
      console.warn(
        `HAProxy not available on port ${SEAL_METERED_PORT}. Some tests will be skipped.`
      );
    }

    if (!lmHealth) {
      console.warn(
        'Local Manager not available. Vault sync tests will be skipped.'
      );
    }
  });

  test.beforeEach(async ({ page }, testInfo) => {
    // Initialize stability checker and capture initial PIDs
    stabilityChecker = new ServiceStabilityChecker(page.request);
    stabilityChecker.setTestName(testInfo.title);
    await stabilityChecker.captureInitialState();

    // Reset customer to clean state
    await resetCustomer(page.request);

    // Clear cookies for clean auth state
    await page.context().clearCookies();

    // Authenticate with mock wallet
    await page.goto('/');
    await page.click('button:has-text("Mock Wallet 0")');
    await waitAfterMutation(page);
    await page.waitForURL('/dashboard', { timeout: 10000 });

    // Ensure customer has balance for subscription
    await ensureTestBalance(page.request, 1000, { spendingLimitUsd: 250 });
  });

  test.afterEach(async () => {
    // Verify services didn't restart during test (throws if PIDs changed)
    // This catches infrastructure instability that causes intermittent failures
    await stabilityChecker.verifyServicesStable();
  });

  test('full user flow: subscribe, configure, and verify vault sync', async ({ page }) => {
    test.setTimeout(90000); // Extended timeout for full flow

    // Check if LM is available
    const lmHealth = await getLMHealth();
    if (!lmHealth) {
      test.skip();
      return;
    }

    // === STEP 1: Subscribe to Seal service through UI ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });

    // Accept terms and select STARTER tier
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();

    // Subscribe to service
    const subscribeButton = page.locator('button:has-text("Subscribe to Service")');
    await subscribeButton.click();

    // Wait for subscription success
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    console.log('✅ Subscription successful - API key auto-created');

    // Wait for redirect to overview
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // === STEP 2: Enable the service via UI toggle ===
    const serviceToggle = page.locator('button[role="switch"]');
    const toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
      console.log('✅ Service enabled');
    }

    // === STEP 3: Create a Seal Key via UI (required for cpEnabled) ===
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);

    const addKeyButton = page.locator('button:has-text("Add New Seal Key")');
    await addKeyButton.click();
    await waitAfterMutation(page);
    await expect(
      page.locator('text=/Seal key created successfully/i')
    ).toBeVisible({ timeout: 5000 });
    console.log('✅ Seal key created');

    // === STEP 4: Add a package to trigger cpEnabled=true ===
    const addPackageButton = page
      .locator('button:has-text("Add Package to this Seal Key")')
      .first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);

    await expect(
      page.getByRole('heading', { name: 'Add Package' })
    ).toBeVisible({ timeout: 5000 });
    await page.locator('input#packageAddress').fill('0x' + '1'.repeat(64));
    await page.locator('input#name').fill('Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    console.log('✅ Package added - cpEnabled=true');

    // === STEP 5: Verify API key exists and get it via test endpoint ===
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);

    const apiKey = apiKeys[0].fullKey;
    const apiKeyFp = apiKeys[0].apiKeyFp;
    expect(apiKey).toBeDefined();
    expect(apiKey.length).toBe(37); // Expected format: S + 36 chars
    console.log(`✅ API key retrieved: ${apiKey.substring(0, 10)}...`);

    // === STEP 6: Wait for vault sync ===
    // Get customer ID and wait for customer to appear in HAProxy config
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    const configCheck = await waitForHAProxyConfig(customerId, {}, { timeout: 60000 });
    if (!configCheck.ok) {
      throw new Error(`HAProxy config not applied: ${configCheck.error}`);
    }
    console.log(`✅ Customer ${customerId} in HAProxy config (version=${configCheck.version})`);

    // === STEP 7: Verify UI clipboard copy matches API key ===
    // This ensures what users copy from the UI matches what we use for testing
    // Note: Done AFTER vault sync because UI may filter keys during "Updating" state
    await page.goto('/services/seal/overview?tab=x-api-key');
    await waitAfterMutation(page);

    // Wait for the specific API key row to be visible - this is the ultimate goal
    // The row has data-testid="apik-{fingerprint}" which we know from STEP 5
    // This handles all race conditions: loading states, sync status, query timing
    const apiKeyRow = page.locator(`[data-testid="apik-${apiKeyFp}"]`);
    await expect(apiKeyRow).toBeVisible({ timeout: 30000 });

    // Click the copy button (the Copy icon button inside CopyableValue)
    const copyButton = apiKeyRow.locator('button').first();
    await copyButton.click();

    // Read clipboard content (requires clipboard-read permission granted in playwright config)
    const clipboardContent = await page.evaluate(() => navigator.clipboard.readText());

    // Verify clipboard matches the API key from tRPC
    expect(clipboardContent).toBe(apiKey);
    console.log(`✅ UI clipboard copy verified: matches API key from tRPC`);
  });

  test('HAProxy health check with valid API key', async ({ page }) => {
    test.setTimeout(120000); // Extended timeout for full flow

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();

    if (!haproxyAvailable) {
      console.log('Skipping: HAProxy not available');
      test.skip();
      return;
    }

    if (!lmHealth) {
      console.log('Skipping: LM not available');
      test.skip();
      return;
    }

    // === Subscribe and configure through UI (real user experience) ===

    // Navigate to Seal service
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });

    // Accept terms and subscribe
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service
    const serviceToggle = page.locator('button[role="switch"]');
    const toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    // Add package (triggers cpEnabled)
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '2'.repeat(64));
    await page.locator('input#name').fill('HAProxy Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);

    // Get API key via test endpoint
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);
    const apiKey = apiKeys[0].fullKey;
    console.log(`API key from UI flow: ${apiKey.substring(0, 10)}... (${apiKey.length} chars)`);

    // Get customer ID and wait for both customer config AND API key to be synced
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    const configCheck = await waitForHAProxyReady(customerId, apiKey, { timeout: 60000 });
    if (!configCheck.ok) {
      throw new Error(`HAProxy not ready: ${configCheck.error}`);
    }

    // === Now make a real health check request through HAProxy (metered port) ===
    const healthResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });

    console.log('Health check response:', healthResponse);

    // Verify the response
    if (healthResponse.status === 401) {
      console.warn(
        'HAProxy returned 401 - API key validation failed'
      );
      console.log('Response body:', healthResponse.body);
    }

    // For now, we expect either success or a specific error we can debug
    // 200 = success, 401/403 = auth issue, 502/503 = backend issue
    expect([200, 401, 403, 502, 503]).toContain(healthResponse.status);

    if (healthResponse.status === 200) {
      console.log('✅ HAProxy health check succeeded with valid API key!');
    }
  });

  test('local port (20202) bypasses API key validation - returns 200', async () => {
    // Check if HAProxy is available on local port
    const haproxyAvailable = await isHAProxyAvailable();
    if (!haproxyAvailable) {
      console.log('Skipping: HAProxy not available on local port');
      test.skip();
      return;
    }

    // Check if the real Seal backend (mseal1) is running
    const backendAvailable = await isSealBackendAvailable();
    expect(backendAvailable,
      'Seal backend (mseal1) not running on port 20401. Start it with: sudo systemctl start mseal1-node'
    ).toBe(true);
    console.log('✅ Seal backend (mseal1) is healthy');

    // Make request without API key on local port
    // Local port (20202) is unmetered and bypasses API key validation
    const response = await sealHealthCheck({
      apiKey: '', // No API key
      port: SEAL_LOCAL_PORT,
    });

    console.log('Response on local port without API key:', response);

    // Local port MUST return 200 to prove:
    // 1. API key validation was bypassed (not 401)
    // 2. Request reached the backend successfully (not 502/503)
    expect(response.status).toBe(200);
    console.log('✅ Local port bypasses API key validation - got 200 from backend');
  });

  test('service toggle triggers vault sync - metered port validates GLIM', async ({ page }) => {
    test.setTimeout(180000); // Extended timeout for full flow with vault sync

    // Prerequisites:
    // - HAProxy with X_API_KEY_SECRET configured (shared with API server)
    // - LM running and applying vaults to HAProxy
    // - GM running for vault generation
    // - mseal1 backend running
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth) {
      console.log('Skipping: HAProxy or LM not available');
      test.skip();
      return;
    }

    expect(backendAvailable,
      'Seal backend (mseal1) not running on port 20401. Start it with: sudo systemctl start mseal1-node'
    ).toBe(true);

    // === STEP 1: Subscribe and configure through UI ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service initially
    const serviceToggle = page.locator('button[role="switch"]');
    let toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    // Add package (triggers cpEnabled)
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '3'.repeat(64));
    await page.locator('input#name').fill('Toggle Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    console.log('✅ Service configured with seal key and package');

    // Get API key for metered port requests
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);
    const apiKey = apiKeys[0].fullKey;
    console.log(`✅ API key retrieved: ${apiKey.substring(0, 10)}... (${apiKey.length} chars)`);

    // Get customer ID for HAProxy config verification
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    console.log(`Customer ID: ${customerId}`);

    // Wait for both customer config AND API key to be synced to HAProxy
    let configCheck = await waitForHAProxyReady(customerId, apiKey, { timeout: 60000 });
    if (!configCheck.ok) {
      throw new Error(`HAProxy not ready: ${configCheck.error}`);
    }

    // === STEP 2: Verify service ON returns 200 via metered port with API key ===
    // This validates the full flow: API key decryption → customer lookup → GLIM check → backend
    let response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });
    console.log('Service ON response on metered port:', response);
    expect(response.status).toBe(200);
    console.log('✅ Service ON: metered port returns 200 (API key valid, GLIM>0)');

    // === STEP 3: Turn OFF service via UI toggle ===
    await page.goto('/services/seal/overview');
    await waitAfterMutation(page);
    const toggleOff = page.locator('button[role="switch"]');
    toggleState = await toggleOff.getAttribute('aria-checked');
    if (toggleState === 'true') {
      await toggleOff.click();
      await waitAfterMutation(page);
    }
    console.log('✅ Service toggled OFF via UI');

    // Wait for HAProxy config to update with GLIM=0 (service disabled)
    const previousVersion = configCheck.version;
    configCheck = await waitForHAProxyConfig(customerId, { glim: 0 }, { timeout: 60000, minVersion: previousVersion });
    if (!configCheck.ok) {
      throw new Error(`HAProxy config not updated after OFF: ${configCheck.error}`);
    }
    console.log(`✅ HAProxy config updated after OFF (version=${configCheck.version}, GLIM=${configCheck.glim}, was=${previousVersion})`);

    // === STEP 4: Verify service OFF returns 403 via metered port ===
    // When isUserEnabled=false, GLIM=0 in config map → HAProxy returns 403
    // Wait for HAProxy to fully apply the change (map update != immediate enforcement)
    const offResult = await waitForHealthCheckStatus(apiKey, 403);
    console.log(`Service OFF response: ${offResult.status}`);

    // API key is valid (not 401), but customer not authorized (GLIM=0 → 403)
    expect(offResult.status).toBe(403);
    console.log('✅ Service OFF: metered port returns 403 (API key valid, but GLIM=0)');

    // === STEP 5: Turn ON service via UI toggle ===
    const toggleOn = page.locator('button[role="switch"]');
    toggleState = await toggleOn.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await toggleOn.click();
      await waitAfterMutation(page);
    }
    console.log('✅ Service toggled ON via UI');

    // Wait for HAProxy config to update (version must increment again)
    const offVersion = configCheck.version;
    configCheck = await waitForHAProxyConfig(customerId, {}, { timeout: 60000, minVersion: offVersion });
    if (!configCheck.ok) {
      throw new Error(`HAProxy config not updated after ON: ${configCheck.error}`);
    }
    console.log(`✅ HAProxy config updated after ON (version=${configCheck.version}, was=${offVersion})`);

    // === STEP 6: Verify service ON returns 200 again via metered port ===
    // Wait for HAProxy to fully apply the change
    const onResult = await waitForHealthCheckStatus(apiKey, 200);
    console.log(`Service ON (restored) response: ${onResult.status}`);
    expect(onResult.status).toBe(200);
    console.log('✅ Service ON: metered port returns 200 again (GLIM restored)');
  });

  test('metered port (20002) rejects request without API key', async () => {
    // Check if HAProxy is available on metered port
    const haproxyAvailable = await isHAProxyAvailable();
    if (!haproxyAvailable) {
      test.skip();
      return;
    }

    // Make request without API key on metered port
    const response = await sealHealthCheck({
      apiKey: '', // Empty API key
      port: SEAL_METERED_PORT,
    });

    console.log('Response on metered port without API key:', response);

    // Metered port should reject with 401 (missing API key)
    expect(response.status).toBe(401);
    console.log('✅ Metered port correctly rejects missing API key');
  });

  test('metered port (20002) rejects request with invalid API key', async () => {
    // Check if HAProxy is available on metered port
    const haproxyAvailable = await isHAProxyAvailable();
    if (!haproxyAvailable) {
      test.skip();
      return;
    }

    // Make request with invalid API key (wrong format/checksum)
    const response = await sealHealthCheck({
      apiKey: 'SINVALIDAPIKEY12345678901234567890',
      port: SEAL_METERED_PORT,
    });

    console.log('Response on metered port with invalid API key:', response);

    // Metered port should reject with 401 (invalid API key)
    expect(response.status).toBe(401);
    console.log('✅ Metered port correctly rejects invalid API key');
  });
});

test.describe('Real Seal Requests - Infrastructure Checks', () => {
  test('HAProxy stats endpoint is accessible', async () => {
    try {
      const response = await fetch('http://localhost:1936/haproxy?stats');
      console.log(`HAProxy stats: ${response.status}`);
      // Stats endpoint should be available even if Seal frontend isn't configured
      expect(response.status).toBe(200);
    } catch (error) {
      console.log('HAProxy stats not available:', error);
      test.skip();
    }
  });

  test('Local Manager health endpoint is accessible', async () => {
    const health = await getLMHealth();
    if (!health) {
      console.log('LM not available');
      test.skip();
      return;
    }

    expect(health.service).toBe('local-manager');
    expect(health.vaults).toBeDefined();
    console.log('LM health:', JSON.stringify(health, null, 2));
  });

  test('Global Manager is accessible', async () => {
    try {
      const response = await fetch(`${GM_URL}/api/health`);
      if (!response.ok) {
        console.log('GM not available');
        test.skip();
        return;
      }

      const health = await response.json();
      console.log('GM health:', JSON.stringify(health, null, 2));
      expect(health).toBeDefined();
    } catch {
      console.log('GM not available');
      test.skip();
    }
  });
});

/**
 * IP Allowlist E2E Tests
 *
 * Tests that HAProxy correctly blocks/allows requests based on IP allowlist:
 * 1. Customer configures IP allowlist via UI (PRO tier required)
 * 2. Vault is generated with IP filter encoded in mapConfigHex
 * 3. LM applies vault to HAProxy
 * 4. HAProxy checks CF-Connecting-IP header against allowlist
 * 5. Allowed IPs get 200, non-allowed IPs get 403
 *
 * Test Strategy:
 * - Uses CF-Connecting-IP header to simulate different client IPs
 * - This is the production mechanism (HAProxy trusts CF-Connecting-IP from Cloudflare)
 * - In tests, we can set any IP since we bypass the Cloudflare firewall
 */
test.describe('Real Seal Requests - IP Allowlist', () => {
  // Service stability checker - detects unexpected service restarts during tests
  let stabilityChecker: ServiceStabilityChecker;

  test.beforeEach(async ({ page }, testInfo) => {
    // Initialize stability checker and capture initial PIDs
    stabilityChecker = new ServiceStabilityChecker(page.request);
    stabilityChecker.setTestName(testInfo.title);
    await stabilityChecker.captureInitialState();

    // Reset customer to clean state
    await resetCustomer(page.request);

    // Clear cookies for clean auth state
    await page.context().clearCookies();

    // Authenticate with mock wallet
    await page.goto('/');
    await page.click('button:has-text("Mock Wallet 0")');
    await waitAfterMutation(page);
    await page.waitForURL('/dashboard', { timeout: 10000 });

    // Ensure customer has balance for subscription
    await ensureTestBalance(page.request, 1000, { spendingLimitUsd: 250 });
  });

  test.afterEach(async () => {
    // Verify services didn't restart during test (throws if PIDs changed)
    await stabilityChecker.verifyServicesStable();
  });

  test('IP allowlist blocks non-allowed IP with 403', async ({ page }) => {
    test.setTimeout(180000); // Extended timeout for full flow with vault sync

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth) {
      console.log('Skipping: HAProxy or LM not available');
      test.skip();
      return;
    }

    if (!backendAvailable) {
      console.log('Skipping: Seal backend (mseal1) not running on port 20401');
      test.skip();
      return;
    }

    // === STEP 1: Subscribe to PRO tier (IP allowlist requires PRO+) ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });

    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'PRO' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });
    console.log('✅ Subscribed to PRO tier');

    // === STEP 2: Enable service and create seal key + package (for cpEnabled) ===
    const serviceToggle = page.locator('button[role="switch"]');
    const toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    // Add package (triggers cpEnabled)
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '3'.repeat(64));
    await page.locator('input#name').fill('IP Allowlist Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    await expect(page.locator('text=Package added successfully').first()).toBeVisible({ timeout: 5000 });
    console.log('✅ Seal key and package created (cpEnabled=true)');

    // Get API key
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);
    const apiKey = apiKeys[0].fullKey;
    console.log(`API key: ${apiKey.substring(0, 10)}...`);

    // === STEP 3: Configure IP allowlist via UI ===
    // The allowed IP will be 1.2.3.4 - we'll test with this and another IP
    const ALLOWED_IP = '1.2.3.4';
    const BLOCKED_IP = '9.8.7.6';

    await page.goto('/services/seal/overview?tab=more-settings');
    await waitAfterMutation(page);

    // Enable IP allowlist toggle
    await page.locator('#ip-allowlist-toggle').click();
    await page.waitForTimeout(1000);

    // Enter allowed IP
    const textarea = page.locator('#ip-allowlist');
    await textarea.fill(ALLOWED_IP);
    await page.waitForTimeout(300);

    // Save
    await page.locator('button:has-text("Save Changes")').click();
    await page.waitForTimeout(1500);
    await expect(page.locator('text=/IP Allowlist saved successfully/i')).toBeVisible({ timeout: 5000 });
    console.log(`✅ IP allowlist configured: ${ALLOWED_IP}`);

    // === STEP 4: Get customer ID and trigger vault sync ===
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    console.log(`Customer ID: ${customerId}`);

    // Wait for HAProxy config to have our IP allowlist with the expected config
    // Natural sync will happen - no explicit trigger (production-like behavior)
    // This is more reliable than waiting for vault seq because it verifies actual config
    const configCheck = await waitForHAProxyConfig(customerId, {
      hasIpAllowlist: true,
      inlineIps: [ALLOWED_IP],
    }, { timeout: 60000 });

    if (!configCheck.ok) {
      console.error('HAProxy config verification failed:', configCheck.error);
      console.log('Config state:', JSON.stringify(configCheck, null, 2));
      throw new Error(`HAProxy config not applied: ${configCheck.error}`);
    }
    console.log('✅ HAProxy config verified: IP allowlist with inline IP');

    // === STEP 5: Test with allowed IP - should get 200 ===
    const allowedResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: ALLOWED_IP,
    });
    console.log(`Response with allowed IP (${ALLOWED_IP}):`, allowedResponse.status, allowedResponse.statusText);

    expect(allowedResponse.status).toBe(200);
    console.log('✅ Allowed IP gets 200');

    // === STEP 6: Test with blocked IP - should get 403 ===
    const blockedResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: BLOCKED_IP,
    });
    console.log(`Response with blocked IP (${BLOCKED_IP}):`, blockedResponse.status, blockedResponse.statusText);

    expect(blockedResponse.status).toBe(403);
    expect(blockedResponse.body).toContain('IP not allowlisted');
    console.log('✅ Blocked IP gets 403 "IP not allowlisted"');
  });

  test('IP allowlist allows second IP in list', async ({ page }) => {
    test.setTimeout(180000);

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth || !backendAvailable) {
      console.log('Skipping: Prerequisites not met');
      test.skip();
      return;
    }

    // Subscribe to PRO tier
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'PRO' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service
    const serviceToggle = page.locator('button[role="switch"]');
    if ((await serviceToggle.getAttribute('aria-checked')) === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key + package
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '4'.repeat(64));
    await page.locator('input#name').fill('IP Allowlist Test 2');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    await expect(page.locator('text=Package added successfully').first()).toBeVisible({ timeout: 5000 });
    console.log('✅ Seal key and package created (cpEnabled=true)');

    const apiKeys = await getApiKeys(page.request);
    const apiKey = apiKeys[0].fullKey;

    // Configure IP allowlist with TWO IPs
    const IP_1 = '10.20.30.40';
    const IP_2 = '50.60.70.80';
    const BLOCKED_IP = '99.99.99.99';

    await page.goto('/services/seal/overview?tab=more-settings');
    await waitAfterMutation(page);
    await page.locator('#ip-allowlist-toggle').click();
    await page.waitForTimeout(1000);

    const textarea = page.locator('#ip-allowlist');
    await textarea.fill(`${IP_1}, ${IP_2}`);
    await page.waitForTimeout(300);
    await page.locator('button:has-text("Save Changes")').click();
    await page.waitForTimeout(1500);
    console.log(`✅ IP allowlist configured: ${IP_1}, ${IP_2}`);

    // Get customer ID for HAProxy config verification
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    console.log(`Customer ID: ${customerId}`);

    // Wait for HAProxy config to have both IPs in the inline filter
    // Natural sync will happen - no explicit trigger (production-like behavior)
    // This verifies the actual config is applied, not just a version number
    const configCheck = await waitForHAProxyConfig(customerId, {
      hasIpAllowlist: true,
      inlineIps: [IP_1, IP_2],
    }, { timeout: 60000 });

    if (!configCheck.ok) {
      console.error('HAProxy config verification failed:', configCheck.error);
      console.log('Config state:', JSON.stringify(configCheck, null, 2));
      throw new Error(`HAProxy config not applied: ${configCheck.error}`);
    }
    console.log(`✅ HAProxy config verified: IP allowlist with inline IPs [${configCheck.inlineIps?.join(', ')}]`);

    // Test first IP - should be allowed
    const response1 = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: IP_1,
    });
    expect(response1.status).toBe(200);
    console.log(`✅ First IP (${IP_1}) gets 200`);

    // Test second IP - should also be allowed
    const response2 = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: IP_2,
    });
    expect(response2.status).toBe(200);
    console.log(`✅ Second IP (${IP_2}) gets 200`);

    // Test blocked IP - should get 403
    const blockedResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: BLOCKED_IP,
    });
    expect(blockedResponse.status).toBe(403);
    console.log(`✅ Blocked IP (${BLOCKED_IP}) gets 403`);
  });

  test('disabling IP allowlist allows all IPs again', async ({ page }) => {
    test.setTimeout(180000);

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth || !backendAvailable) {
      console.log('Skipping: Prerequisites not met');
      test.skip();
      return;
    }

    // Subscribe to PRO tier
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'PRO' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service + create seal key/package
    const serviceToggle = page.locator('button[role="switch"]');
    if ((await serviceToggle.getAttribute('aria-checked')) === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '5'.repeat(64));
    await page.locator('input#name').fill('IP Allowlist Toggle Test');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    await expect(page.locator('text=Package added successfully').first()).toBeVisible({ timeout: 5000 });
    console.log('✅ Seal key and package created (cpEnabled=true)');

    const apiKeys = await getApiKeys(page.request);
    const apiKey = apiKeys[0].fullKey;

    const ALLOWED_IP = '11.22.33.44';
    const OTHER_IP = '55.66.77.88';

    // === STEP 1: Enable IP allowlist with specific IP ===
    await page.goto('/services/seal/overview?tab=more-settings');
    await waitAfterMutation(page);
    await page.locator('#ip-allowlist-toggle').click();
    await page.waitForTimeout(1000);

    const textarea = page.locator('#ip-allowlist');
    await textarea.fill(ALLOWED_IP);
    await page.locator('button:has-text("Save Changes")').click();
    await page.waitForTimeout(1500);

    // Get customer ID for HAProxy config verification
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    console.log(`Customer ID: ${customerId}`);

    // Wait for HAProxy config to match expected state
    let configCheck = await waitForHAProxyConfig(customerId, {
      hasIpAllowlist: true,
      inlineIps: [ALLOWED_IP],
    }, { timeout: 60000 });

    if (!configCheck.ok) {
      throw new Error(`HAProxy config not applied: ${configCheck.error}`);
    }
    console.log(`✅ HAProxy config verified: IP allowlist enabled (version=${configCheck.version})`);

    // Capture version from Step 1 to verify Step 2 generates a new vault
    const step1Version = configCheck.version;

    // Verify OTHER_IP is blocked
    let otherResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: OTHER_IP,
    });
    expect(otherResponse.status).toBe(403);
    console.log(`✅ With allowlist ON: ${OTHER_IP} is blocked (403)`);

    // === STEP 2: Disable IP allowlist ===
    await page.locator('#ip-allowlist-toggle').click();
    await page.waitForTimeout(1500);

    // Wait for HAProxy config to reflect the change
    configCheck = await waitForHAProxyConfig(customerId, {
      hasIpAllowlist: false,
    }, { timeout: 60000, minVersion: step1Version });

    if (!configCheck.ok) {
      throw new Error(`HAProxy config not applied after disable: ${configCheck.error}`);
    }
    console.log(`✅ HAProxy config verified: IP allowlist disabled (version=${configCheck.version}, was=${step1Version})`);

    // === STEP 3: Verify OTHER_IP is now allowed ===
    otherResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: OTHER_IP,
    });
    expect(otherResponse.status).toBe(200);
    console.log(`✅ With allowlist OFF: ${OTHER_IP} is allowed (200)`);
  });
});

/**
 * HAProxy Log Ingestion E2E Tests
 *
 * Tests the full fluentd log pipeline:
 * 1. Request goes through HAProxy
 * 2. HAProxy logs to rsyslog
 * 3. rsyslog forwards to fluentd-lm (port 22500)
 * 4. fluentd-lm aggregates and forwards to fluentd-gm (port 24224)
 * 5. fluentd-gm inserts to PostgreSQL haproxy_raw_logs table
 * 6. Test queries the database to verify the log arrived
 *
 * Prerequisites:
 * - fluentd-lm and fluentd-gm services running
 * - rsyslog configured to forward HAProxy logs
 * - PostgreSQL with haproxy_raw_logs table
 */
test.describe('Real Seal Requests - Log Ingestion', () => {
  // Service stability checker - detects unexpected service restarts during tests
  let stabilityChecker: ServiceStabilityChecker;

  test.beforeEach(async ({ page }, testInfo) => {
    // Initialize stability checker and capture initial PIDs
    stabilityChecker = new ServiceStabilityChecker(page.request);
    stabilityChecker.setTestName(testInfo.title);
    await stabilityChecker.captureInitialState();

    // Reset customer to clean state
    await resetCustomer(page.request);

    // Clear cookies for clean auth state
    await page.context().clearCookies();

    // Authenticate with mock wallet
    await page.goto('/');
    await page.click('button:has-text("Mock Wallet 0")');
    await waitAfterMutation(page);
    await page.waitForURL('/dashboard', { timeout: 10000 });

    // Ensure customer has balance for subscription
    await ensureTestBalance(page.request, 1000, { spendingLimitUsd: 250 });
  });

  test.afterEach(async () => {
    // Verify services didn't restart during test (throws if PIDs changed)
    await stabilityChecker.verifyServicesStable();
  });

  test('HAProxy request is logged to database via fluentd pipeline', async ({ page }) => {
    test.setTimeout(180000); // Extended timeout for full flow with log ingestion

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth) {
      console.log('Skipping: HAProxy or LM not available');
      test.skip();
      return;
    }

    if (!backendAvailable) {
      console.log('Skipping: Seal backend (mseal1) not running on port 20401');
      test.skip();
      return;
    }

    // === STEP 1: Subscribe and configure through UI ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });
    console.log('✅ Subscribed to STARTER tier');

    // Enable service
    const serviceToggle = page.locator('button[role="switch"]');
    if ((await serviceToggle.getAttribute('aria-checked')) === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key + package
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '6'.repeat(64));
    await page.locator('input#name').fill('Log Ingestion Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    console.log('✅ Seal key and package created');

    // Get API key
    const apiKeys = await getApiKeys(page.request);
    const apiKey = apiKeys[0].fullKey;
    console.log(`API key: ${apiKey.substring(0, 10)}...`);

    // Get customer ID and wait for both customer config AND API key to be synced
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    const configCheck = await waitForHAProxyReady(customerId, apiKey, { timeout: 60000 });
    if (!configCheck.ok) {
      throw new Error(`HAProxy not ready: ${configCheck.error}`);
    }

    // === STEP 2: Record timestamp before making request ===
    // Subtract 1 second because HAProxy logs only have second precision,
    // so a request made at :33.870 might be logged as :33.000
    const beforeRequest = new Date(Date.now() - 1000);

    // === STEP 3: Make health check request through HAProxy ===
    const response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });
    console.log(`Health check response: ${response.status}`);
    expect(response.status).toBe(200);
    console.log('✅ Health check succeeded');

    // === STEP 4: Wait for log to appear in database ===
    // The fluentd pipeline has some latency:
    // - fluentd-lm aggregates for 1 second window
    // - Buffer flushes every 0.5 seconds
    // - fluentd-gm processes and inserts to PostgreSQL
    console.log('Waiting for log to appear in database...');

    const logs = await waitForHaproxyLogs(page.request, {
      since: beforeRequest,
      minCount: 1,
      timeout: 30000, // 30 seconds for fluentd pipeline (1s aggregation + buffer flushes)
      pollInterval: 2000,
      statusCode: 200,
    });

    // === STEP 5: Verify the log entry ===
    expect(logs.length).toBeGreaterThanOrEqual(1);
    const logEntry = logs[0];

    console.log('Log entry found:', JSON.stringify(logEntry, null, 2));

    // Verify key fields
    expect(logEntry.statusCode).toBe(200);
    expect(logEntry.serviceType).toBeGreaterThan(0); // Seal service type
    expect(logEntry.repeat).toBeGreaterThanOrEqual(1);

    console.log('✅ HAProxy log successfully ingested to database via fluentd pipeline!');
    console.log(`   - Timestamp: ${logEntry.timestamp}`);
    console.log(`   - Status: ${logEntry.statusCode}`);
    console.log(`   - Service Type: ${logEntry.serviceType}`);
    console.log(`   - Path Prefix: ${logEntry.pathPrefix}`);
    console.log(`   - Repeat: ${logEntry.repeat}`);
  });
});
