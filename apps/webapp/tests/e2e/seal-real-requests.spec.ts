/**
 * Real Seal Requests E2E Tests
 *
 * Tests the full production flow (real user experience):
 * 1. Customer subscribes to Seal service through UI
 * 2. Customer creates seal key + package through UI (triggers cpEnabled)
 * 3. API key is auto-created during subscription
 * 4. Vault is generated by GM with customer config
 * 5. LM applies vault to HAProxy
 * 6. Real HTTP requests through HAProxy using API key
 *
 * Prerequisites:
 * - HAProxy running with Seal frontend configured
 * - Local Manager (LM) running and consuming vaults
 * - Global Manager (GM) running for vault generation
 * - API server running with test endpoints
 *
 * Port reference (~/walrus/PORT_MAP.md):
 * - 20202: SEAL local access (unmetered) - used for testing
 * - 22600: Global Manager API
 * - 22610: Local Manager API
 * - 22700: API Server
 */

import { test, expect } from '@playwright/test';
import { waitAfterMutation } from '../helpers/wait-utils';
import { resetCustomer, ensureTestBalance, getCustomerData, waitForHaproxyLogs } from '../helpers/db';
// Note: We intentionally don't use setupCpEnabled or createApiKey shortcuts
// to test the real user experience through the UI
import {
  sealHealthCheck,
  isHAProxyAvailable,
  isSealBackendAvailable,
  SEAL_PORTS,
} from '../helpers/seal-requests';

// Service URLs
const LM_URL = 'http://localhost:22610';
const GM_URL = 'http://localhost:22600';
const API_URL = 'http://localhost:22700';

// Test configuration
// Use MAINNET_PUBLIC (20002) for API key validation tests - this is the metered frontend
// that validates X-API-Key headers. MAINNET_LOCAL (20202) is unmetered and skips validation.
const SEAL_METERED_PORT = SEAL_PORTS.MAINNET_PUBLIC; // 20002 - metered, validates API keys
const SEAL_LOCAL_PORT = SEAL_PORTS.MAINNET_LOCAL; // 20202 - unmetered, no API key validation

// LM health response structure
interface LMHealthResponse {
  service: string;
  timestamp: string;
  vaults: Array<{
    type: string;
    customerCount: number;
    applied: { seq: number; at: string } | null;
    processing: object | null;
  }>;
}

// Helper to get LM health status
async function getLMHealth(): Promise<LMHealthResponse | null> {
  try {
    const response = await fetch(`${LM_URL}/api/health`);
    if (!response.ok) return null;
    return response.json();
  } catch {
    return null;
  }
}

// Helper to wait for vault to propagate and be applied by LM
// Options:
// - requireCustomers: if true, also waits for customerCount > 0
async function waitForVaultSync(expectedMinSeq: number, options?: { requireCustomers?: boolean }): Promise<number> {
  const maxAttempts = 120; // 60 seconds total (increased for race condition handling)
  const pollInterval = 500;
  const requireCustomers = options?.requireCustomers ?? false;

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const health = await getLMHealth();
    if (health) {
      const smaVault = health.vaults.find((v) => v.type === 'sma');
      if (
        smaVault?.applied &&
        smaVault.applied.seq >= expectedMinSeq &&
        !smaVault.processing &&
        (!requireCustomers || smaVault.customerCount > 0)
      ) {
        console.log(
          `Vault sync detected after ${(attempt + 1) * pollInterval}ms (seq=${smaVault.applied.seq}, customers=${smaVault.customerCount})`
        );
        return smaVault.customerCount;
      }
    }
    await new Promise((resolve) => setTimeout(resolve, pollInterval));
  }

  throw new Error(
    `Vault sync timed out after ${maxAttempts * pollInterval}ms waiting for seq >= ${expectedMinSeq}${requireCustomers ? ' with customers' : ''}`
  );
}

// Helper to trigger GM vault generation
async function triggerGMSync(): Promise<void> {
  await fetch(`${GM_URL}/api/queue/sync-all?source=e2e-real-seal-test`, {
    method: 'POST',
  });
}

// Sudob API URL (privileged service for root operations)
const SUDOB_URL = 'http://127.0.0.1:22800';

// HAProxy config verification result
interface HAProxyConfigCheck {
  ok: boolean;
  version: number;
  customerId: number | null;
  controlFlags: number | null;
  hasIpAllowlist: boolean | null;
  inlineIps: string[] | null;
  error?: string;
}

// Helper to verify HAProxy config.map contains expected customer config
// Uses sudob to query HAProxy socket directly
async function verifyHAProxyConfig(
  customerId: number,
  expectedConfig?: {
    hasIpAllowlist?: boolean;
    inlineIps?: string[];
  }
): Promise<HAProxyConfigCheck> {
  const result: HAProxyConfigCheck = {
    ok: false,
    version: 0,
    customerId: null,
    controlFlags: null,
    hasIpAllowlist: null,
    inlineIps: null,
  };

  try {
    // Query HAProxy config.map via sudob
    const response = await fetch(`${SUDOB_URL}/api/haproxy/socket`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ command: 'show map /etc/haproxy/conf.d/204-mseal_config.map' }),
    });

    if (!response.ok) {
      result.error = `Sudob request failed: ${response.status}`;
      return result;
    }

    const data = await response.json();
    if (!data.ok) {
      result.error = `HAProxy socket error: ${data.error}`;
      return result;
    }

    // Parse the map output
    const lines = data.output.split('\n');
    for (const line of lines) {
      // Parse __version__ metadata
      const versionMatch = line.match(/__version__\s+(\d+)/);
      if (versionMatch) {
        result.version = parseInt(versionMatch[1], 10);
        continue;
      }

      // Parse customer entry: <hex_id> <customer_id> <config_csv>
      // Format: 0x75e178e99080 1886853509 0000010060620002,ad8cf08d00000000,0a141e28323c4650,0000000000000000
      const customerMatch = line.match(/0x[0-9a-f]+\s+(\d+)\s+([0-9a-f]{16}),([0-9a-f]{16}),([0-9a-f]{16}),([0-9a-f]{16})/i);
      if (customerMatch && parseInt(customerMatch[1], 10) === customerId) {
        result.customerId = customerId;

        // Parse header (16 hex chars): 00000ILGLBLQCCCC
        // Control flags are last 4 hex chars
        const headerHex = customerMatch[2];
        result.controlFlags = parseInt(headerHex.slice(-4), 16);
        result.hasIpAllowlist = (result.controlFlags & 0x0002) !== 0;

        // Parse IP filter (16 hex chars): IP1(8hex)IP2(8hex)
        const ipFilterHex = customerMatch[4];
        const ip1Hex = ipFilterHex.slice(0, 8);
        const ip2Hex = ipFilterHex.slice(8, 16);

        // Convert hex to IP address
        const hexToIp = (hex: string): string | null => {
          const num = parseInt(hex, 16);
          if (num === 0) return null;
          return [
            (num >>> 24) & 0xff,
            (num >>> 16) & 0xff,
            (num >>> 8) & 0xff,
            num & 0xff,
          ].join('.');
        };

        const ip1 = hexToIp(ip1Hex);
        const ip2 = hexToIp(ip2Hex);
        result.inlineIps = [ip1, ip2].filter(Boolean) as string[];

        break;
      }
    }

    // Verify expected config if provided
    if (expectedConfig) {
      if (result.customerId === null) {
        result.error = `Customer ${customerId} not found in HAProxy config.map`;
        return result;
      }

      if (expectedConfig.hasIpAllowlist !== undefined) {
        if (result.hasIpAllowlist !== expectedConfig.hasIpAllowlist) {
          result.error = `IP allowlist bit mismatch: expected ${expectedConfig.hasIpAllowlist}, got ${result.hasIpAllowlist}`;
          return result;
        }
      }

      if (expectedConfig.inlineIps) {
        const expectedIpsSet = new Set(expectedConfig.inlineIps);
        const actualIpsSet = new Set(result.inlineIps || []);
        const missing = expectedConfig.inlineIps.filter(ip => !actualIpsSet.has(ip));
        if (missing.length > 0) {
          result.error = `Missing inline IPs: expected ${expectedConfig.inlineIps.join(',')}, got ${result.inlineIps?.join(',') || 'none'}`;
          return result;
        }
      }
    }

    result.ok = true;
    return result;
  } catch (error) {
    result.error = `Exception: ${error instanceof Error ? error.message : String(error)}`;
    return result;
  }
}

// Helper to wait for HAProxy config to match expected state
// This is more reliable than waiting for vault seq because it verifies actual config
async function waitForHAProxyConfig(
  customerId: number,
  expectedConfig: {
    hasIpAllowlist?: boolean;
    inlineIps?: string[];
  },
  options?: { timeout?: number; pollInterval?: number }
): Promise<HAProxyConfigCheck> {
  const timeout = options?.timeout ?? 30000;
  const pollInterval = options?.pollInterval ?? 500;
  const maxAttempts = Math.ceil(timeout / pollInterval);

  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const result = await verifyHAProxyConfig(customerId, expectedConfig);

    if (result.ok) {
      console.log(
        `HAProxy config verified after ${(attempt + 1) * pollInterval}ms: ` +
        `version=${result.version}, controlFlags=0x${result.controlFlags?.toString(16)}, ` +
        `hasIpAllowlist=${result.hasIpAllowlist}, inlineIps=[${result.inlineIps?.join(',')}]`
      );
      return result;
    }

    if (attempt < maxAttempts - 1) {
      await new Promise((resolve) => setTimeout(resolve, pollInterval));
    }
  }

  // Return last result with error
  const finalResult = await verifyHAProxyConfig(customerId);
  finalResult.error = `Timeout waiting for HAProxy config: ${finalResult.error || 'config not found'}`;
  return finalResult;
}

// API key type from listApiKeys endpoint
interface ApiKeyInfo {
  apiKeyFp: number;
  keyPreview: string;
  fullKey: string;
  metadata: unknown;
  isUserEnabled: boolean;
  createdAt: string;
  revokedAt: string | null;
}

// Helper to get API keys via test endpoint
// This endpoint doesn't require authentication and returns decrypted keys
async function getApiKeys(request: import('@playwright/test').APIRequestContext): Promise<ApiKeyInfo[]> {
  const response = await request.get(`${API_URL}/test/data/api-keys`);
  if (!response.ok()) {
    throw new Error(`Failed to get API keys: ${await response.text()}`);
  }
  const data = await response.json();
  // Test endpoint returns { apiKeys: [...] } with apiKeyId (decrypted key)
  return (data.apiKeys || []).map((k: any) => ({
    apiKeyFp: k.apiKeyFp,
    keyPreview: `${k.apiKeyId.slice(0, 8)}...${k.apiKeyId.slice(-4)}`,
    fullKey: k.apiKeyId, // apiKeyId is the decrypted full key
    metadata: k.metadata,
    isUserEnabled: k.isUserEnabled,
    createdAt: k.createdAt,
    revokedAt: k.revokedAt,
  }));
}

test.describe('Real Seal Requests', () => {
  test.beforeAll(async () => {
    // Check prerequisites - HAProxy and LM must be running
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();

    if (!haproxyAvailable) {
      console.warn(
        `HAProxy not available on port ${SEAL_METERED_PORT}. Some tests will be skipped.`
      );
    }

    if (!lmHealth) {
      console.warn(
        'Local Manager not available. Vault sync tests will be skipped.'
      );
    }
  });

  test.beforeEach(async ({ page }) => {
    // Reset customer to clean state
    await resetCustomer(page.request);

    // Clear cookies for clean auth state
    await page.context().clearCookies();

    // Authenticate with mock wallet
    await page.goto('/');
    await page.click('button:has-text("Mock Wallet")');
    await waitAfterMutation(page);
    await page.waitForURL('/dashboard', { timeout: 10000 });

    // Ensure customer has balance for subscription
    await ensureTestBalance(page.request, 1000, { spendingLimitUsd: 250 });
  });

  test('full user flow: subscribe, configure, and verify vault sync', async ({ page }) => {
    test.setTimeout(90000); // Extended timeout for full flow

    // Check if LM is available
    const lmHealth = await getLMHealth();
    if (!lmHealth) {
      test.skip();
      return;
    }

    // Get initial vault sequence for later comparison
    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;
    console.log(`Initial vault seq: ${initialSeq}`);

    // === STEP 1: Subscribe to Seal service through UI ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });

    // Accept terms and select STARTER tier
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();

    // Subscribe to service
    const subscribeButton = page.locator('button:has-text("Subscribe to Service")');
    await subscribeButton.click();

    // Wait for subscription success
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    console.log('✅ Subscription successful - API key auto-created');

    // Wait for redirect to overview
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // === STEP 2: Enable the service via UI toggle ===
    const serviceToggle = page.locator('button[role="switch"]');
    const toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
      console.log('✅ Service enabled');
    }

    // === STEP 3: Create a Seal Key via UI (required for cpEnabled) ===
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);

    const addKeyButton = page.locator('button:has-text("Add New Seal Key")');
    await addKeyButton.click();
    await waitAfterMutation(page);
    await expect(
      page.locator('text=/Seal key created successfully/i')
    ).toBeVisible({ timeout: 5000 });
    console.log('✅ Seal key created');

    // === STEP 4: Add a package to trigger cpEnabled=true ===
    const addPackageButton = page
      .locator('button:has-text("Add Package to this Seal Key")')
      .first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);

    await expect(
      page.getByRole('heading', { name: 'Add Package' })
    ).toBeVisible({ timeout: 5000 });
    await page.locator('input#packageAddress').fill('0x' + '1'.repeat(64));
    await page.locator('input#name').fill('Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    console.log('✅ Package added - cpEnabled=true');

    // === STEP 5: Verify API key exists and get it via test endpoint ===
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);

    const apiKey = apiKeys[0].fullKey;
    const apiKeyFp = apiKeys[0].apiKeyFp;
    expect(apiKey).toBeDefined();
    expect(apiKey.length).toBe(37); // Expected format: S + 36 chars
    console.log(`✅ API key retrieved: ${apiKey.substring(0, 10)}...`);

    // === STEP 5b: Verify UI clipboard copy matches API key ===
    // This ensures what users copy from the UI matches what we use for testing
    await page.goto('/services/seal/overview?tab=x-api-key');
    await waitAfterMutation(page);

    // Find the API key row by its fingerprint and click the copy button
    const apiKeyRow = page.locator(`[data-testid="apik-${apiKeyFp}"]`);
    await expect(apiKeyRow).toBeVisible({ timeout: 5000 });

    // Click the copy button (the Copy icon button inside CopyableValue)
    const copyButton = apiKeyRow.locator('button').first();
    await copyButton.click();

    // Read clipboard content (requires clipboard-read permission granted in playwright config)
    const clipboardContent = await page.evaluate(() => navigator.clipboard.readText());

    // Verify clipboard matches the API key from tRPC
    expect(clipboardContent).toBe(apiKey);
    console.log(`✅ UI clipboard copy verified: matches API key from tRPC`);

    // === STEP 6: Trigger GM vault generation ===
    await triggerGMSync();
    console.log('✅ GM vault sync triggered');

    // === STEP 7: Wait for vault to be applied by LM with our customer ===
    // Use requireCustomers to handle race condition where vault might be applied
    // before our cpEnabled change is included
    const customerCount = await waitForVaultSync(initialSeq + 1, { requireCustomers: true });
    console.log(`✅ Vault sync complete - ${customerCount} customer(s) in HAProxy`);
  });

  test('HAProxy health check with valid API key', async ({ page }) => {
    test.setTimeout(120000); // Extended timeout for full flow

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();

    if (!haproxyAvailable) {
      console.log('Skipping: HAProxy not available');
      test.skip();
      return;
    }

    if (!lmHealth) {
      console.log('Skipping: LM not available');
      test.skip();
      return;
    }

    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;

    // === Subscribe and configure through UI (real user experience) ===

    // Navigate to Seal service
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });

    // Accept terms and subscribe
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service
    const serviceToggle = page.locator('button[role="switch"]');
    const toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    // Add package (triggers cpEnabled)
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '2'.repeat(64));
    await page.locator('input#name').fill('HAProxy Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);

    // Get API key via test endpoint
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);
    const apiKey = apiKeys[0].fullKey;
    console.log(`API key from UI flow: ${apiKey.substring(0, 10)}... (${apiKey.length} chars)`);

    // Trigger vault sync and wait for our customer to be included
    await triggerGMSync();
    await waitForVaultSync(initialSeq + 1, { requireCustomers: true });

    // === Now make a real health check request through HAProxy (metered port) ===
    const healthResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });

    console.log('Health check response:', healthResponse);

    // Verify the response
    if (healthResponse.status === 401) {
      console.warn(
        'HAProxy returned 401 - API key validation failed'
      );
      console.log('Response body:', healthResponse.body);
    }

    // For now, we expect either success or a specific error we can debug
    // 200 = success, 401/403 = auth issue, 502/503 = backend issue
    expect([200, 401, 403, 502, 503]).toContain(healthResponse.status);

    if (healthResponse.status === 200) {
      console.log('✅ HAProxy health check succeeded with valid API key!');
    }
  });

  test('local port (20202) bypasses API key validation - returns 200', async () => {
    // Check if HAProxy is available on local port
    const haproxyAvailable = await isHAProxyAvailable();
    if (!haproxyAvailable) {
      console.log('Skipping: HAProxy not available on local port');
      test.skip();
      return;
    }

    // Check if the real Seal backend (mseal1) is running
    const backendAvailable = await isSealBackendAvailable();
    expect(backendAvailable,
      'Seal backend (mseal1) not running on port 20401. Start it with: sudo systemctl start mseal1-node'
    ).toBe(true);
    console.log('✅ Seal backend (mseal1) is healthy');

    // Make request without API key on local port
    // Local port (20202) is unmetered and bypasses API key validation
    const response = await sealHealthCheck({
      apiKey: '', // No API key
      port: SEAL_LOCAL_PORT,
    });

    console.log('Response on local port without API key:', response);

    // Local port MUST return 200 to prove:
    // 1. API key validation was bypassed (not 401)
    // 2. Request reached the backend successfully (not 502/503)
    expect(response.status).toBe(200);
    console.log('✅ Local port bypasses API key validation - got 200 from backend');
  });

  test('service toggle triggers vault sync - metered port validates GLIM', async ({ page }) => {
    test.setTimeout(180000); // Extended timeout for full flow with vault sync

    // Prerequisites:
    // - HAProxy with X_API_KEY_SECRET configured (shared with API server)
    // - LM running and applying vaults to HAProxy
    // - GM running for vault generation
    // - mseal1 backend running
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth) {
      console.log('Skipping: HAProxy or LM not available');
      test.skip();
      return;
    }

    expect(backendAvailable,
      'Seal backend (mseal1) not running on port 20401. Start it with: sudo systemctl start mseal1-node'
    ).toBe(true);

    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;

    // === STEP 1: Subscribe and configure through UI ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service initially
    const serviceToggle = page.locator('button[role="switch"]');
    let toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    // Add package (triggers cpEnabled)
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '3'.repeat(64));
    await page.locator('input#name').fill('Toggle Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    console.log('✅ Service configured with seal key and package');

    // Get API key for metered port requests
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);
    const apiKey = apiKeys[0].fullKey;
    console.log(`✅ API key retrieved: ${apiKey.substring(0, 10)}... (${apiKey.length} chars)`);

    // Trigger vault sync and wait for customer to be included
    await triggerGMSync();
    await waitForVaultSync(initialSeq + 1, { requireCustomers: true });
    console.log('✅ Initial vault sync complete');

    // === STEP 2: Verify service ON returns 200 via metered port with API key ===
    // This validates the full flow: API key decryption → customer lookup → GLIM check → backend
    let response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });
    console.log('Service ON response on metered port:', response);
    expect(response.status).toBe(200);
    console.log('✅ Service ON: metered port returns 200 (API key valid, GLIM>0)');

    // === STEP 3: Turn OFF service via UI toggle ===
    await page.goto('/services/seal/overview');
    await waitAfterMutation(page);
    const toggleOff = page.locator('button[role="switch"]');
    toggleState = await toggleOff.getAttribute('aria-checked');
    if (toggleState === 'true') {
      await toggleOff.click();
      await waitAfterMutation(page);
    }
    console.log('✅ Service toggled OFF via UI');

    // Trigger vault sync and wait
    const seqAfterOff = (await getLMHealth())?.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;
    await triggerGMSync();
    await waitForVaultSync(seqAfterOff + 1, { requireCustomers: true });
    console.log('✅ Vault sync after OFF complete');

    // === STEP 4: Verify service OFF returns 403 via metered port ===
    // When isUserEnabled=false, GLIM=0 in config map → HAProxy returns 403
    response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });
    console.log('Service OFF response on metered port:', response);

    // API key is valid (not 401), but customer not authorized (GLIM=0 → 403)
    expect(response.status).toBe(403);
    console.log('✅ Service OFF: metered port returns 403 (API key valid, but GLIM=0)');

    // === STEP 5: Turn ON service via UI toggle ===
    const toggleOn = page.locator('button[role="switch"]');
    toggleState = await toggleOn.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await toggleOn.click();
      await waitAfterMutation(page);
    }
    console.log('✅ Service toggled ON via UI');

    // Trigger vault sync and wait
    const seqAfterOn = (await getLMHealth())?.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;
    await triggerGMSync();
    await waitForVaultSync(seqAfterOn + 1, { requireCustomers: true });
    console.log('✅ Vault sync after ON complete');

    // === STEP 6: Verify service ON returns 200 again via metered port ===
    response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });
    console.log('Service ON (restored) response on metered port:', response);
    expect(response.status).toBe(200);
    console.log('✅ Service ON: metered port returns 200 again (GLIM restored)');
  });

  test('metered port (20002) rejects request without API key', async () => {
    // Check if HAProxy is available on metered port
    const haproxyAvailable = await isHAProxyAvailable();
    if (!haproxyAvailable) {
      test.skip();
      return;
    }

    // Make request without API key on metered port
    const response = await sealHealthCheck({
      apiKey: '', // Empty API key
      port: SEAL_METERED_PORT,
    });

    console.log('Response on metered port without API key:', response);

    // Metered port should reject with 401 (missing API key)
    expect(response.status).toBe(401);
    console.log('✅ Metered port correctly rejects missing API key');
  });

  test('metered port (20002) rejects request with invalid API key', async () => {
    // Check if HAProxy is available on metered port
    const haproxyAvailable = await isHAProxyAvailable();
    if (!haproxyAvailable) {
      test.skip();
      return;
    }

    // Make request with invalid API key (wrong format/checksum)
    const response = await sealHealthCheck({
      apiKey: 'SINVALIDAPIKEY12345678901234567890',
      port: SEAL_METERED_PORT,
    });

    console.log('Response on metered port with invalid API key:', response);

    // Metered port should reject with 401 (invalid API key)
    expect(response.status).toBe(401);
    console.log('✅ Metered port correctly rejects invalid API key');
  });
});

test.describe('Real Seal Requests - Infrastructure Checks', () => {
  test('HAProxy stats endpoint is accessible', async () => {
    try {
      const response = await fetch('http://localhost:1936/haproxy?stats');
      console.log(`HAProxy stats: ${response.status}`);
      // Stats endpoint should be available even if Seal frontend isn't configured
      expect(response.status).toBe(200);
    } catch (error) {
      console.log('HAProxy stats not available:', error);
      test.skip();
    }
  });

  test('Local Manager health endpoint is accessible', async () => {
    const health = await getLMHealth();
    if (!health) {
      console.log('LM not available');
      test.skip();
      return;
    }

    expect(health.service).toBe('local-manager');
    expect(health.vaults).toBeDefined();
    console.log('LM health:', JSON.stringify(health, null, 2));
  });

  test('Global Manager is accessible', async () => {
    try {
      const response = await fetch(`${GM_URL}/api/health`);
      if (!response.ok) {
        console.log('GM not available');
        test.skip();
        return;
      }

      const health = await response.json();
      console.log('GM health:', JSON.stringify(health, null, 2));
      expect(health).toBeDefined();
    } catch {
      console.log('GM not available');
      test.skip();
    }
  });
});

/**
 * IP Allowlist E2E Tests
 *
 * Tests that HAProxy correctly blocks/allows requests based on IP allowlist:
 * 1. Customer configures IP allowlist via UI (PRO tier required)
 * 2. Vault is generated with IP filter encoded in mapConfigHex
 * 3. LM applies vault to HAProxy
 * 4. HAProxy checks CF-Connecting-IP header against allowlist
 * 5. Allowed IPs get 200, non-allowed IPs get 403
 *
 * Test Strategy:
 * - Uses CF-Connecting-IP header to simulate different client IPs
 * - This is the production mechanism (HAProxy trusts CF-Connecting-IP from Cloudflare)
 * - In tests, we can set any IP since we bypass the Cloudflare firewall
 */
test.describe('Real Seal Requests - IP Allowlist', () => {
  test.beforeEach(async ({ page }) => {
    // Reset customer to clean state
    await resetCustomer(page.request);

    // Clear cookies for clean auth state
    await page.context().clearCookies();

    // Authenticate with mock wallet
    await page.goto('/');
    await page.click('button:has-text("Mock Wallet")');
    await waitAfterMutation(page);
    await page.waitForURL('/dashboard', { timeout: 10000 });

    // Ensure customer has balance for subscription
    await ensureTestBalance(page.request, 1000, { spendingLimitUsd: 250 });
  });

  test('IP allowlist blocks non-allowed IP with 403', async ({ page }) => {
    test.setTimeout(180000); // Extended timeout for full flow with vault sync

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth) {
      console.log('Skipping: HAProxy or LM not available');
      test.skip();
      return;
    }

    if (!backendAvailable) {
      console.log('Skipping: Seal backend (mseal1) not running on port 20401');
      test.skip();
      return;
    }

    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;

    // === STEP 1: Subscribe to PRO tier (IP allowlist requires PRO+) ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });

    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'PRO' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });
    console.log('✅ Subscribed to PRO tier');

    // === STEP 2: Enable service and create seal key + package (for cpEnabled) ===
    const serviceToggle = page.locator('button[role="switch"]');
    const toggleState = await serviceToggle.getAttribute('aria-checked');
    if (toggleState === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    await expect(page.locator('text=/Seal key created successfully/i')).toBeVisible({ timeout: 5000 });

    // Add package (triggers cpEnabled)
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '3'.repeat(64));
    await page.locator('input#name').fill('IP Allowlist Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    console.log('✅ Seal key and package created (cpEnabled=true)');

    // Get API key
    const apiKeys = await getApiKeys(page.request);
    expect(apiKeys.length).toBeGreaterThan(0);
    const apiKey = apiKeys[0].fullKey;
    console.log(`API key: ${apiKey.substring(0, 10)}...`);

    // === STEP 3: Configure IP allowlist via UI ===
    // The allowed IP will be 1.2.3.4 - we'll test with this and another IP
    const ALLOWED_IP = '1.2.3.4';
    const BLOCKED_IP = '9.8.7.6';

    await page.goto('/services/seal/overview?tab=more-settings');
    await waitAfterMutation(page);

    // Enable IP allowlist toggle
    await page.locator('#ip-allowlist-toggle').click();
    await page.waitForTimeout(1000);

    // Enter allowed IP
    const textarea = page.locator('#ip-allowlist');
    await textarea.fill(ALLOWED_IP);
    await page.waitForTimeout(300);

    // Save
    await page.locator('button:has-text("Save Changes")').click();
    await page.waitForTimeout(1500);
    await expect(page.locator('text=/IP Allowlist saved successfully/i')).toBeVisible({ timeout: 5000 });
    console.log(`✅ IP allowlist configured: ${ALLOWED_IP}`);

    // === STEP 4: Get customer ID and trigger vault sync ===
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    console.log(`Customer ID: ${customerId}`);

    // Trigger GM sync to pick up the latest DB state
    await triggerGMSync();
    // Small delay to allow GM to process the sync
    await page.waitForTimeout(500);

    // Wait for HAProxy config to have our IP allowlist with the expected config
    // This is more reliable than waiting for vault seq because it verifies actual config
    const configCheck = await waitForHAProxyConfig(customerId, {
      hasIpAllowlist: true,
      inlineIps: [ALLOWED_IP],
    }, { timeout: 60000 });

    if (!configCheck.ok) {
      console.error('HAProxy config verification failed:', configCheck.error);
      console.log('Config state:', JSON.stringify(configCheck, null, 2));
      throw new Error(`HAProxy config not applied: ${configCheck.error}`);
    }
    console.log('✅ HAProxy config verified: IP allowlist with inline IP');

    // === STEP 5: Test with allowed IP - should get 200 ===
    const allowedResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: ALLOWED_IP,
    });
    console.log(`Response with allowed IP (${ALLOWED_IP}):`, allowedResponse.status, allowedResponse.statusText);

    expect(allowedResponse.status).toBe(200);
    console.log('✅ Allowed IP gets 200');

    // === STEP 6: Test with blocked IP - should get 403 ===
    const blockedResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: BLOCKED_IP,
    });
    console.log(`Response with blocked IP (${BLOCKED_IP}):`, blockedResponse.status, blockedResponse.statusText);

    expect(blockedResponse.status).toBe(403);
    expect(blockedResponse.body).toContain('IP not allowlisted');
    console.log('✅ Blocked IP gets 403 "IP not allowlisted"');
  });

  test('IP allowlist allows second IP in list', async ({ page }) => {
    test.setTimeout(180000);

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth || !backendAvailable) {
      console.log('Skipping: Prerequisites not met');
      test.skip();
      return;
    }

    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;

    // Subscribe to PRO tier
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'PRO' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service
    const serviceToggle = page.locator('button[role="switch"]');
    if ((await serviceToggle.getAttribute('aria-checked')) === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key + package
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '4'.repeat(64));
    await page.locator('input#name').fill('IP Allowlist Test 2');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);

    const apiKeys = await getApiKeys(page.request);
    const apiKey = apiKeys[0].fullKey;

    // Configure IP allowlist with TWO IPs
    const IP_1 = '10.20.30.40';
    const IP_2 = '50.60.70.80';
    const BLOCKED_IP = '99.99.99.99';

    await page.goto('/services/seal/overview?tab=more-settings');
    await waitAfterMutation(page);
    await page.locator('#ip-allowlist-toggle').click();
    await page.waitForTimeout(1000);

    const textarea = page.locator('#ip-allowlist');
    await textarea.fill(`${IP_1}, ${IP_2}`);
    await page.waitForTimeout(300);
    await page.locator('button:has-text("Save Changes")').click();
    await page.waitForTimeout(1500);
    console.log(`✅ IP allowlist configured: ${IP_1}, ${IP_2}`);

    // Get customer ID for HAProxy config verification
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    console.log(`Customer ID: ${customerId}`);

    // Trigger vault sync
    await triggerGMSync();
    await page.waitForTimeout(500);

    // Wait for HAProxy config to have both IPs in the inline filter
    // This verifies the actual config is applied, not just a version number
    const configCheck = await waitForHAProxyConfig(customerId, {
      hasIpAllowlist: true,
      inlineIps: [IP_1, IP_2],
    }, { timeout: 60000 });

    if (!configCheck.ok) {
      console.error('HAProxy config verification failed:', configCheck.error);
      console.log('Config state:', JSON.stringify(configCheck, null, 2));
      throw new Error(`HAProxy config not applied: ${configCheck.error}`);
    }
    console.log(`✅ HAProxy config verified: IP allowlist with inline IPs [${configCheck.inlineIps?.join(', ')}]`);

    // Test first IP - should be allowed
    const response1 = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: IP_1,
    });
    expect(response1.status).toBe(200);
    console.log(`✅ First IP (${IP_1}) gets 200`);

    // Test second IP - should also be allowed
    const response2 = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: IP_2,
    });
    expect(response2.status).toBe(200);
    console.log(`✅ Second IP (${IP_2}) gets 200`);

    // Test blocked IP - should get 403
    const blockedResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: BLOCKED_IP,
    });
    expect(blockedResponse.status).toBe(403);
    console.log(`✅ Blocked IP (${BLOCKED_IP}) gets 403`);
  });

  test('disabling IP allowlist allows all IPs again', async ({ page }) => {
    test.setTimeout(180000);

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth || !backendAvailable) {
      console.log('Skipping: Prerequisites not met');
      test.skip();
      return;
    }

    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;

    // Subscribe to PRO tier
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'PRO' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });

    // Enable service + create seal key/package
    const serviceToggle = page.locator('button[role="switch"]');
    if ((await serviceToggle.getAttribute('aria-checked')) === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '5'.repeat(64));
    await page.locator('input#name').fill('IP Allowlist Toggle Test');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);

    const apiKeys = await getApiKeys(page.request);
    const apiKey = apiKeys[0].fullKey;

    const ALLOWED_IP = '11.22.33.44';
    const OTHER_IP = '55.66.77.88';

    // === STEP 1: Enable IP allowlist with specific IP ===
    await page.goto('/services/seal/overview?tab=more-settings');
    await waitAfterMutation(page);
    await page.locator('#ip-allowlist-toggle').click();
    await page.waitForTimeout(1000);

    const textarea = page.locator('#ip-allowlist');
    await textarea.fill(ALLOWED_IP);
    await page.locator('button:has-text("Save Changes")').click();
    await page.waitForTimeout(1500);

    // Get customer ID for HAProxy config verification
    const customerData = await getCustomerData(page.request);
    const customerId = customerData.customer?.customerId as number;
    console.log(`Customer ID: ${customerId}`);

    // Trigger vault sync and wait for HAProxy config with IP allowlist
    await triggerGMSync();
    await page.waitForTimeout(500);

    let configCheck = await waitForHAProxyConfig(customerId, {
      hasIpAllowlist: true,
      inlineIps: [ALLOWED_IP],
    }, { timeout: 60000 });

    if (!configCheck.ok) {
      throw new Error(`HAProxy config not applied: ${configCheck.error}`);
    }
    console.log(`✅ HAProxy config verified: IP allowlist enabled`);

    // Verify OTHER_IP is blocked
    let otherResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: OTHER_IP,
    });
    expect(otherResponse.status).toBe(403);
    console.log(`✅ With allowlist ON: ${OTHER_IP} is blocked (403)`);

    // === STEP 2: Disable IP allowlist ===
    await page.locator('#ip-allowlist-toggle').click();
    await page.waitForTimeout(1500);

    // Trigger vault sync and wait for HAProxy config WITHOUT IP allowlist
    await triggerGMSync();
    await page.waitForTimeout(500);

    configCheck = await waitForHAProxyConfig(customerId, {
      hasIpAllowlist: false,
    }, { timeout: 60000 });

    if (!configCheck.ok) {
      throw new Error(`HAProxy config not applied after disable: ${configCheck.error}`);
    }
    console.log('✅ HAProxy config verified: IP allowlist disabled');

    // === STEP 3: Verify OTHER_IP is now allowed ===
    otherResponse = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
      clientIp: OTHER_IP,
    });
    expect(otherResponse.status).toBe(200);
    console.log(`✅ With allowlist OFF: ${OTHER_IP} is allowed (200)`);
  });
});

/**
 * HAProxy Log Ingestion E2E Tests
 *
 * Tests the full fluentd log pipeline:
 * 1. Request goes through HAProxy
 * 2. HAProxy logs to rsyslog
 * 3. rsyslog forwards to lm-fluentd (port 22500)
 * 4. lm-fluentd aggregates and forwards to gm-fluentd (port 24224)
 * 5. gm-fluentd inserts to PostgreSQL haproxy_raw_logs table
 * 6. Test queries the database to verify the log arrived
 *
 * Prerequisites:
 * - lm-fluentd and gm-fluentd services running
 * - rsyslog configured to forward HAProxy logs
 * - PostgreSQL with haproxy_raw_logs table
 */
test.describe('Real Seal Requests - Log Ingestion', () => {
  test.beforeEach(async ({ page }) => {
    // Reset customer to clean state
    await resetCustomer(page.request);

    // Clear cookies for clean auth state
    await page.context().clearCookies();

    // Authenticate with mock wallet
    await page.goto('/');
    await page.click('button:has-text("Mock Wallet")');
    await waitAfterMutation(page);
    await page.waitForURL('/dashboard', { timeout: 10000 });

    // Ensure customer has balance for subscription
    await ensureTestBalance(page.request, 1000, { spendingLimitUsd: 250 });
  });

  test('HAProxy request is logged to database via fluentd pipeline', async ({ page }) => {
    test.setTimeout(180000); // Extended timeout for full flow with log ingestion

    // Check prerequisites
    const haproxyAvailable = await isHAProxyAvailable();
    const lmHealth = await getLMHealth();
    const backendAvailable = await isSealBackendAvailable();

    if (!haproxyAvailable || !lmHealth) {
      console.log('Skipping: HAProxy or LM not available');
      test.skip();
      return;
    }

    if (!backendAvailable) {
      console.log('Skipping: Seal backend (mseal1) not running on port 20401');
      test.skip();
      return;
    }

    const initialSeq = lmHealth.vaults.find((v) => v.type === 'sma')?.applied?.seq ?? 0;

    // === STEP 1: Subscribe and configure through UI ===
    await page.click('text=Seal');
    await page.waitForURL(/\/services\/seal/, { timeout: 5000 });
    await page.locator('label:has-text("Agree to")').click();
    await page.getByRole('heading', { name: 'STARTER' }).click();
    await page.locator('button:has-text("Subscribe to Service")').click();
    await expect(page.locator('text=/Subscription successful/i')).toBeVisible({ timeout: 5000 });
    await page.waitForURL(/\/services\/seal\/overview/, { timeout: 10000 });
    console.log('✅ Subscribed to STARTER tier');

    // Enable service
    const serviceToggle = page.locator('button[role="switch"]');
    if ((await serviceToggle.getAttribute('aria-checked')) === 'false') {
      await serviceToggle.click();
      await waitAfterMutation(page);
    }

    // Create seal key + package
    await page.goto('/services/seal/overview?tab=seal-keys');
    await waitAfterMutation(page);
    await page.locator('button:has-text("Add New Seal Key")').click();
    await waitAfterMutation(page);
    const addPackageButton = page.locator('button:has-text("Add Package to this Seal Key")').first();
    await expect(addPackageButton).toBeVisible({ timeout: 5000 });
    await addPackageButton.click();
    await waitAfterMutation(page);
    await page.locator('input#packageAddress').fill('0x' + '6'.repeat(64));
    await page.locator('input#name').fill('Log Ingestion Test Package');
    await page.locator('button:has-text("Add Package")').last().click();
    await waitAfterMutation(page);
    console.log('✅ Seal key and package created');

    // Get API key
    const apiKeys = await getApiKeys(page.request);
    const apiKey = apiKeys[0].fullKey;
    console.log(`API key: ${apiKey.substring(0, 10)}...`);

    // Trigger vault sync
    await triggerGMSync();
    await waitForVaultSync(initialSeq + 1, { requireCustomers: true });
    console.log('✅ Vault sync complete');

    // === STEP 2: Record timestamp before making request ===
    // Subtract 1 second because HAProxy logs only have second precision,
    // so a request made at :33.870 might be logged as :33.000
    const beforeRequest = new Date(Date.now() - 1000);

    // === STEP 3: Make health check request through HAProxy ===
    const response = await sealHealthCheck({
      apiKey,
      port: SEAL_METERED_PORT,
    });
    console.log(`Health check response: ${response.status}`);
    expect(response.status).toBe(200);
    console.log('✅ Health check succeeded');

    // === STEP 4: Wait for log to appear in database ===
    // The fluentd pipeline has some latency:
    // - lm-fluentd aggregates for 1 second window
    // - Buffer flushes every 0.5 seconds
    // - gm-fluentd processes and inserts to PostgreSQL
    console.log('Waiting for log to appear in database...');

    const logs = await waitForHaproxyLogs(page.request, {
      since: beforeRequest,
      minCount: 1,
      timeout: 30000, // 30 seconds for fluentd pipeline (1s aggregation + buffer flushes)
      pollInterval: 2000,
      statusCode: 200,
    });

    // === STEP 5: Verify the log entry ===
    expect(logs.length).toBeGreaterThanOrEqual(1);
    const logEntry = logs[0];

    console.log('Log entry found:', JSON.stringify(logEntry, null, 2));

    // Verify key fields
    expect(logEntry.statusCode).toBe(200);
    expect(logEntry.serviceType).toBeGreaterThan(0); // Seal service type
    expect(logEntry.repeat).toBeGreaterThanOrEqual(1);

    console.log('✅ HAProxy log successfully ingested to database via fluentd pipeline!');
    console.log(`   - Timestamp: ${logEntry.timestamp}`);
    console.log(`   - Status: ${logEntry.statusCode}`);
    console.log(`   - Service Type: ${logEntry.serviceType}`);
    console.log(`   - Path Prefix: ${logEntry.pathPrefix}`);
    console.log(`   - Repeat: ${logEntry.repeat}`);
  });
});
