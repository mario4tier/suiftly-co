/**
 * Invoice Management
 *
 * Handles creation and lifecycle of billing invoices (DRAFT, PENDING, PAID, FAILED, VOIDED).
 *
 * See BILLING_DESIGN.md for invoice lifecycle and DRAFT model requirements.
 */

import { eq, and, sql } from 'drizzle-orm';
import type { Database, DatabaseOrTransaction } from '../db';
import type { LockedTransaction } from './locking';
import { billingRecords, customers, invoiceLineItems } from '../schema';
import type { DBClock } from '@suiftly/shared/db-clock';
import type { InvoiceLineItemType, ServiceType } from '../schema/enums';

/**
 * Line item for an invoice
 *
 * Now uses semantic item types instead of description strings.
 * Types match PostgreSQL ENUMs defined in schema/enums.ts.
 */
export interface InvoiceLineItem {
  itemType: InvoiceLineItemType;
  amountUsdCents: number;
  serviceType?: ServiceType | null;
  quantity?: number;
  unitPriceUsdCents?: number;
  creditMonth?: string;
}

/**
 * Parameters for creating an invoice
 */
export interface CreateInvoiceParams {
  customerId: number;
  amountUsdCents: number;
  type: 'charge' | 'credit' | 'deposit' | 'withdraw';
  status: 'draft' | 'pending';
  description: string; // Kept for logging/debugging
  invoiceNumber?: string;
  billingPeriodStart?: Date;
  billingPeriodEnd?: Date;
  dueDate?: Date;
  billingType?: 'immediate' | 'scheduled'; // Default: 'scheduled'
  // Semantic line item info for immediate charges
  lineItem?: InvoiceLineItem;
}

/**
 * Create a new invoice
 *
 * @param tx Transaction handle
 * @param params Invoice parameters
 * @param clock DBClock for timestamps
 * @returns Created invoice ID
 */
export async function createInvoice(
  tx: DatabaseOrTransaction,
  params: CreateInvoiceParams,
  clock: DBClock
): Promise<string> {
  const now = clock.now();
  const periodStart = params.billingPeriodStart || now;
  const periodEnd = params.billingPeriodEnd || clock.addDays(30);

  const [invoice] = await tx
    .insert(billingRecords)
    .values({
      customerId: params.customerId,
      billingPeriodStart: periodStart,
      billingPeriodEnd: periodEnd,
      amountUsdCents: params.amountUsdCents,
      type: params.type,
      status: params.status,
      invoiceNumber: params.invoiceNumber,
      dueDate: params.dueDate,
      billingType: params.billingType || 'scheduled',
      createdAt: now,
    })
    .returning({ id: billingRecords.id });

  return invoice.id;
}

/**
 * Get or create DRAFT invoice for a customer
 *
 * Per BILLING_DESIGN.md: "Exactly one DRAFT per customer (or none if no enabled services)"
 *
 * @param tx Transaction handle (must have customer lock)
 * @param customerId Customer ID
 * @param clock DBClock for timestamps
 * @returns Existing or newly created DRAFT invoice ID
 */
export async function getOrCreateDraftInvoice(
  tx: LockedTransaction,
  customerId: number,
  clock: DBClock
): Promise<string> {
  // Check for existing DRAFT
  const [existingDraft] = await tx
    .select()
    .from(billingRecords)
    .where(and(
      eq(billingRecords.customerId, customerId),
      eq(billingRecords.status, 'draft')
    ))
    .limit(1);

  if (existingDraft) {
    return existingDraft.id;
  }

  // Create new DRAFT for next billing period
  const today = clock.today();
  const nextMonth = new Date(today);
  nextMonth.setUTCMonth(nextMonth.getUTCMonth() + 1, 1); // 1st of next month

  const periodStart = new Date(Date.UTC(nextMonth.getUTCFullYear(), nextMonth.getUTCMonth(), 1));
  const periodEnd = new Date(Date.UTC(nextMonth.getUTCFullYear(), nextMonth.getUTCMonth() + 1, 0)); // Last day of month

  // Invoice number is auto-generated by database sequence (invoice_number_seq)
  return await createInvoice(
    tx,
    {
      customerId,
      amountUsdCents: 0, // Will be calculated by caller
      type: 'charge',
      status: 'draft',
      description: 'Monthly subscription charges',
      billingPeriodStart: periodStart,
      billingPeriodEnd: periodEnd,
      dueDate: periodStart, // Due on 1st of month
    },
    clock
  );
}

// NOTE: Invoice numbers are auto-generated by database sequence (invoice_number_seq)
// No manual generation function needed - just INSERT without specifying invoice_number

/**
 * Update DRAFT invoice amount
 *
 * Recalculates and updates the DRAFT invoice total based on enabled services.
 * Called when service configuration changes.
 *
 * @param tx Transaction handle (must have customer lock)
 * @param draftInvoiceId DRAFT invoice ID
 * @param newAmountUsdCents New total amount
 */
export async function updateDraftInvoiceAmount(
  tx: LockedTransaction,
  draftInvoiceId: string,
  newAmountUsdCents: number
): Promise<void> {
  await tx
    .update(billingRecords)
    .set({ amountUsdCents: newAmountUsdCents })
    .where(eq(billingRecords.id, draftInvoiceId));
}

/**
 * Transition DRAFT invoice to PENDING
 *
 * Called on the 1st of the month by billing processor.
 *
 * @param tx Transaction handle
 * @param draftInvoiceId DRAFT invoice ID
 */
export async function transitionDraftToPending(
  tx: DatabaseOrTransaction,
  draftInvoiceId: string
): Promise<void> {
  await tx
    .update(billingRecords)
    .set({ status: 'pending' })
    .where(eq(billingRecords.id, draftInvoiceId));
}

/**
 * Create immediate invoice and attempt payment
 *
 * Used for mid-cycle charges (tier upgrades, add-ons, first subscription).
 * Creates PENDING invoice. Invoice number is auto-generated by database sequence.
 *
 * @param tx Transaction handle (must have customer lock)
 * @param params Invoice parameters
 * @param clock DBClock for timestamps
 * @returns Invoice ID
 */
export async function createAndChargeImmediately(
  tx: LockedTransaction,
  params: CreateInvoiceParams,
  clock: DBClock
): Promise<string> {
  // Override status to PENDING and billing type to IMMEDIATE
  // Invoice number is auto-generated by database sequence (invoice_number_seq)
  const invoiceParams = {
    ...params,
    status: 'pending' as const,
    billingType: 'immediate' as const, // Mid-cycle charges are always immediate
  };

  const invoiceId = await createInvoice(tx, invoiceParams, clock);

  // Create line item for this immediate charge
  // This ensures billing history can display the line item
  if (params.lineItem) {
    await tx.insert(invoiceLineItems).values({
      billingRecordId: invoiceId,
      itemType: params.lineItem.itemType,
      serviceType: params.lineItem.serviceType || null,
      quantity: params.lineItem.quantity || 1,
      unitPriceUsdCents: params.lineItem.unitPriceUsdCents || params.amountUsdCents,
      amountUsdCents: params.lineItem.amountUsdCents,
      creditMonth: params.lineItem.creditMonth || null,
    });
  }

  return invoiceId;
}

/**
 * Void an invoice
 *
 * Used for billing errors or corrections.
 *
 * @param tx Transaction handle
 * @param invoiceId Invoice ID to void
 * @param reason Reason for voiding
 */
export async function voidInvoice(
  tx: DatabaseOrTransaction,
  invoiceId: string,
  reason: string
): Promise<void> {
  await tx
    .update(billingRecords)
    .set({
      status: 'voided',
      failureReason: reason,
    })
    .where(eq(billingRecords.id, invoiceId));
}

// ============================================================================
// Two-Phase Commit Pattern for Immediate Charges
// ============================================================================
//
// Problem: On-chain operations (escrow charges) are irreversible, but if the
// server crashes after the on-chain charge but before DB commit, we lose the
// audit trail.
//
// Solution: Create the invoice in a SEPARATE COMMITTED transaction BEFORE
// the on-chain operation. Then if crash occurs after on-chain charge:
// - Invoice exists as 'pending' (from first transaction)
// - Reconciliation job can check on-chain state and update invoice
//
// Flow:
// TRANSACTION 1 (committed immediately):
//   Create invoice as 'pending'
//   COMMIT ← Invoice now exists permanently
//
// TRANSACTION 2 (main operation with lock):
//   Charge escrow on-chain
//   If success: mark invoice 'paid', update tier
//   If fail: mark invoice 'voided'
//   COMMIT (or crash → invoice stays 'pending')
// ============================================================================

import { db } from '../db';

/**
 * Create a pending invoice in a SEPARATE COMMITTED transaction
 *
 * This is the first phase of the two-phase commit pattern. The invoice
 * is created and committed immediately, BEFORE any on-chain operations.
 * This ensures an audit trail exists even if the server crashes after
 * a successful on-chain charge.
 *
 * IMPORTANT: This function commits the invoice immediately in a separate
 * transaction. The invoice will exist even if the caller's transaction
 * rolls back. This is intentional for crash recovery.
 *
 * @param params Invoice parameters
 * @param clock DBClock for timestamps
 * @returns Created invoice ID (committed to database)
 */
export async function createPendingInvoiceCommitted(
  params: Omit<CreateInvoiceParams, 'status' | 'billingType'>,
  clock: DBClock
): Promise<string> {
  // Use a separate transaction that commits immediately
  const invoiceId = await db.transaction(async (tx) => {
    const now = clock.now();
    const periodStart = params.billingPeriodStart || now;
    const periodEnd = params.billingPeriodEnd || clock.addDays(30);

    const [invoice] = await tx
      .insert(billingRecords)
      .values({
        customerId: params.customerId,
        billingPeriodStart: periodStart,
        billingPeriodEnd: periodEnd,
        amountUsdCents: params.amountUsdCents,
        type: params.type,
        status: 'pending', // Always pending for immediate charges
        billingType: 'immediate', // Always immediate - this function is for two-phase commit
        invoiceNumber: params.invoiceNumber,
        dueDate: params.dueDate,
        createdAt: now,
      })
      .returning({ id: billingRecords.id });

    // Create line item for this immediate charge
    // This ensures billing history can display the line item
    if (params.lineItem) {
      await tx.insert(invoiceLineItems).values({
        billingRecordId: invoice.id,
        itemType: params.lineItem.itemType,
        serviceType: params.lineItem.serviceType || null,
        quantity: params.lineItem.quantity || 1,
        unitPriceUsdCents: params.lineItem.unitPriceUsdCents || params.amountUsdCents,
        amountUsdCents: params.lineItem.amountUsdCents,
        creditMonth: params.lineItem.creditMonth || null,
      });
    }

    return invoice.id;
  });

  return invoiceId;
}

/**
 * Mark an invoice as paid (used after successful on-chain charge)
 *
 * @param tx Transaction handle
 * @param invoiceId Invoice ID
 * @param txDigest Transaction digest from on-chain charge
 * @param amountPaidCents Amount paid in cents
 */
export async function markInvoicePaid(
  tx: DatabaseOrTransaction,
  invoiceId: string,
  txDigest: Buffer,
  amountPaidCents: number
): Promise<void> {
  await tx
    .update(billingRecords)
    .set({
      status: 'paid',
      txDigest,
      amountPaidUsdCents: amountPaidCents,
    })
    .where(eq(billingRecords.id, invoiceId));
}

/**
 * Get invoice by ID
 */
export async function getInvoiceById(
  tx: DatabaseOrTransaction,
  invoiceId: string
) {
  const [invoice] = await tx
    .select()
    .from(billingRecords)
    .where(eq(billingRecords.id, invoiceId))
    .limit(1);
  return invoice;
}
